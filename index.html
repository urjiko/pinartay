<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pinartay</title> <!-- Oyun adı güncellendi -->
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; cursor: none; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="space"></canvas>
  <script>
    // Canvas setup
    const canvas = document.getElementById('space');
    const ctx = canvas.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // Function added to CanvasRenderingContext2D prototype for drawing rounded rectangles
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2*r) r = w/2;
      if (h < 2*r) r = h/2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arcTo(x + w, y, x + w, y + r, r);
      this.lineTo(x + w, y + h - r);
      this.arcTo(x + w, y + h, x + w - r, y + h, r);
      this.lineTo(x + r, y + h);
      this.arcTo(x, y + h, x, y + h - r, r);
      this.lineTo(x, y + r);
      this.arcTo(x, y, x + r, y, r);
      this.closePath();
    };

    // Global game state variables
    const letters = "ABCDEFGHIJKLMNOPRSTUVYZ'ÇÖÜİĞŞ".split(''); // Letters to be used
    const FIXED_LETTER_SIZE = 31; // Constant for the fixed size of letters in words

    let particles = []; // Visual effect particles generated when the mouse moves
    let stars = [];      // Letters (stars) floating in space
    let fixedLetters = []; // Letters placed to form a word
    let held = null;     // Current letter/star being dragged by the mouse
    let mouse = { x:0, y:0, px:0, py:0, mx:0, my:0 }; // Mouse position and movement
    let lastMove = Date.now(); // Timestamp of the last mouse movement
    let keyTimers = {}; // To track how long a key has been held down
    let activeKeys = new Set(); // Currently pressed keys

    // New global variables for the final display and animation of words
    let allCompletedWordStars = [];      // Stores arrays of Star objects for each completed word
    let finalDisplayAnimationRunning = false; // True during the 7-second collection animation
    let finalDisplayAnimationStartTime = 0;    // Timestamp when the final display animation started
    let finalDisplayActive = false;        // True when words are permanently fixed in the center

    // New global variables for the background panel
    let panelRect = { x: 0, y: 0, width: 0, height: 0 };
    let panelRadius = 20; // Radius for rounded corners of the panel

    // New global variables for additional effects
    let shootingStars = []; // For the shooting star effect
    let backgroundDots = []; // For static glowing background dots

    // New global variables for constellations
    let piscesConstellationStars = []; // Stars forming the Pisces constellation
    let virgoConstellationStars = [];  // Stars forming the Virgo constellation
    let constellationFormationStartTime = 0; // Start time of the constellation formation animation
    const constellationFormationDuration = 7000; // Constellation formation duration (same as words)

    // USER-PROVIDED COORDINATES FOR PISCES AND VIRGO
    // These coordinates are relative to the *geometric center* of each constellation,
    // which was calculated from the user's provided absolute coordinates.
    // This allows the existing constellation placement logic (canvas.width * 0.25, etc.) to work correctly.

    // Pisces Constellation Shape (21 points, calculated from user's data)
    // C:0, D:1, E:2, F:3, G:4, H:5, I:6, J:7, K:8, L:9, M:10, N:11, O:12, P:13, Q:14, R:15, S:16, T:17, U:18, V:19, W:20
    const piscesShapeRelative = [
        { x: -68.63, y: 199.02 }, { x: -88.63, y: 179.02 }, { x: -79.47, y: 161.42 }, { x: -63.98, y: 137.75 },
        { x: -48.63, y: 99.02 }, { x: -76.26, y: 31.39 }, { x: -99.68, y: -34.74 }, { x: -126.34, y: -106.93 },
        { x: -104.88, y: -97.56 }, { x: -81.87, y: -72.60 }, { x: -57.29, y: -60.89 }, { x: -23.74, y: -46.85 },
        { x: 1.62, y: -32.02 }, { x: 40.24, y: -29.68 }, { x: 153.37, y: -10.57 }, { x: 210.43, y: -9.89 },
        { x: 239.67, y: 6.64 }, { x: 268.07, y: 0.28 }, { x: 278.24, y: -19.21 }, { x: 255.78, y: -45.06 },
        { x: 212.97, y: -48.45 }
    ];

    // Pisces Constellation Connections (Updated based on user's request: C'den W'ya kadar birleşmeli, en son W, R ile birleşmeli)
    const piscesConnections = [
        [0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11],
        [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19], [19, 20],
        [20, 15] // W (index 20) connects to R (index 15)
    ];


    // Virgo Constellation Shape (9 points, calculated from user's data)
    // Z:0, A1:1, B1:2, C1:3, D1:4, E1:5, F1:6, G1:7, H1:8
    const virgoShapeRelative = [
        { x: -4.65, y: 120.13 }, { x: 13.55, y: 39.93 }, { x: 47.51, y: -14.81 },
        { x: 107.14, y: -5.09 }, { x: 185.46, y: 21.80 }, { x: -28.58, y: -59.53 },
        { x: -63.18, y: -114.87 }, { x: -90.27, y: -7.06 }, { x: -166.95, y: 19.46 }
    ];

    // Virgo Constellation Connections (Updated based on user's request)
    const virgoConnections = [
        // Z, A1, B1, C1, D1 sırasıyla birleşmeli
        [0, 1], [1, 2], [2, 3], [3, 4],
        // H1, G1, E1, F1 birleşmeli
        [8, 7], [7, 5], [5, 6],
        // B1 ve E1 birbiriyle birleşmeli
        [2, 5]
    ];


    // Word lists for game progression
    const wordList = ["ALTAY","PINAR'A","ÇOK"]; // Predefined words
    const wordGroups = { // Options for dynamic words based on the first selected letter
      A:["AŞIK", "AZIYOR", "ACİZ", "ATEŞLİ"],
      Ö:["ÖLÜYOR"],
      B:["BİTİYOR", "BAĞIMLI"],
      E:["ERİYOR", "ESİR"],
      Y:["YÜKSELİYOR"],
      T:["TAPIYOR", "TİTRİYOR"],
      H:["HAYRAN"],
      C:["COŞUYOR", "ÇARESİZ"],
      Ç:["ÇABALADI"],
      D:["DELİRİYOR"],
      F:["FETİŞ", "FEDAİ"],
      G:["GÜLÜYOR", "GÖMÜLÜ"],
      I:["ISLAK"],
      İ:["İSTEKLİ"],
      K:["KALP", "KUDURUYOR", "KALDIRIYOR",],
      L:["LOVE", "LAL"],
      M:["MÜPTELA", "MEST"],
      N:["NİYETLİ"],
      O:["OKŞUYOR", "OBSESİF"],
      P:["PSPSPS", "PERVASIZ"],
      R:["RAZI", "RİTİMLİ"],
      S:["SEVİŞİYOR", "SUSMUYOR", "SARHOŞ"],
      Ş:["ŞEHVETLİ"],
      U:["UYAR"],
      Ü:["ÜLFET"],
      V:["VAKUM", "VURGUN"],
      Z:["ZİMMETLİ", "ZARİF"]
    };
    let wordIndex = 0;       // Current index in the predefined word list
    let currentWord = wordList[wordIndex]; // The word currently being formed
    let currentIndex = 0;    // Current letter index within currentWord
    let dynamicMode = false; // True when the first letter of a dynamic word is selected
    let options = [];        // Possible dynamic words after first letter selection
    let secondPhase = false; // True when the second letter of a dynamic word is selected (if multiple options)

    // Particle class (for visual effects)
    class Particle {
      constructor(x,y,vx,vy) {
        this.x=x; this.y=y; // Position
        this.vx=vx; this.vy=vy; // Velocity
        this.life=1; // Lifecycle (decreases over time)
      }
      update() {
        this.x += this.vx; this.y += this.vy; // Move the particle
        this.life -= 0.04; // Decreased lifespan (to make them last shorter)
      }
      draw() {
        if (this.life <= 0.1) return; // Don't draw if almost gone
        ctx.globalAlpha = this.life; // Set transparency based on life
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1, 0, Math.PI*2); // Draw a small white circle (reduced size)
        ctx.fill();
        ctx.globalAlpha = 1; // Reset transparency
      }
    }

    // Star (Letter) class
    class Star {
      constructor(c) {
        this.char = c || letters[Math.floor(Math.random()*letters.length)]; // Assign a random letter or specified letter
        this.x = Math.random()*canvas.width; // Random starting X position
        this.y = Math.random()*canvas.height; // Random starting Y position
        this.vx = (Math.random()-0.5)*0.3; // Random starting X velocity
        this.vy = (Math.random()-0.5)*0.3; // Random starting Y velocity
        this.baseSize = 14 + Math.random()*8; // Base font size
        this.size = this.baseSize; // Current font size
        this.alpha = 0.3 + Math.random()*0.7; // Transparency
        this.angle = Math.random()*Math.PI*2; // Initial rotation angle
        this.spin = (Math.random()-0.5)*0.01; // Rotation speed
        this.fixed = false; // True if the letter is part of a completed word
        this.wordIndex = wordIndex; // Word index this star belongs to (useful for heart transformation)
        this.isAnimatingThrow = false; // True during the throw animation

        // New properties for final display animation and scattering
        this.originalX = this.x;
        this.originalY = this.y;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isFinalDisplayStar = false; // Flag to mark stars that will be part of the final centered display
        this.isScatteredHeart = false;    // Flag to mark as a scattered heart
        this.isBackgroundDot = false;     // Flag for static glowing background dots
        this.isConstellationStar = false; // True if it's part of a constellation

        // New properties for fixed letters: Target positions (for smooth movement)
        this.targetFixedX = null;
        this.targetFixedY = null;
        this.constellationTargetX = null; // Target X for constellation stars
        this.constellationTargetY = null; // Target Y for constellation stars

        // For background dots (this logic triggers if a Star is specifically created as a background dot)
        if (c === '•' && arguments.length === 1) { // If specifically created as a background dot
          this.isBackgroundDot = true;
          this.alpha = 0.1 + Math.random() * 0.7; // Softer glow, but some are brighter
          this.size = 2 + Math.random() * 8; // Dots ranging from smaller to slightly larger
          this.vx = this.vy = 0; // Do not move
          this.char = '•'; // Use a simple dot character
        }
      }
      update() {
        // Background dots do not move (unless they are constellation stars)
        if (this.isBackgroundDot) {
          // If this star is a constellation star and animation is running
          if (this.isConstellationStar && finalDisplayAnimationRunning) {
              const elapsed = Date.now() - constellationFormationStartTime;
              const t = Math.min(1, elapsed / constellationFormationDuration); // Normalize time to 0-1 range
              this.x = this.originalX + (this.constellationTargetX - this.originalX) * t;
              this.y = this.originalY + (this.constellationTargetY - this.originalY) * t;
              this.alpha = 0.5 + 0.5 * t; // Brighten during animation
              this.size = 6 + 4 * t; // Grow a bit
          } else if (this.isConstellationStar && finalDisplayActive) {
              // Stay at fixed position after animation
              this.x = this.constellationTargetX;
              this.y = this.constellationTargetY;
              this.alpha = 1; // Full brightness
              this.size = 10; // Permanent size
          }
          return; // Background dots and constellation stars do not use other movement logic
        }

        // If throw animation is active, skip other movements
        if (this.isAnimatingThrow) {
          return;
        }

        // If this star is a scattered heart, apply unique update logic
        if (this.isScatteredHeart) {
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98; // Damping
            this.vy *= 0.98; // Damping
            this.alpha -= 0.003; // Slowly fade out
            if (this.alpha <= 0) {
                // Remove the star from the global stars array when it completely fades
                const index = stars.indexOf(this);
                if (index > -1) {
                    stars.splice(index, 1);
                }
            }
            return; // Skip other update logic
        }

        // If this star is part of the final, fixed display (ALTAY, PINAR, or the fading 'A)
        if (this.isFinalDisplayStar) {
            if (finalDisplayAnimationRunning) {
                let elapsed = Date.now() - finalDisplayAnimationStartTime;
                let t = Math.min(1, elapsed / 7000); // Normalize duration to 0-1 range (over 7 seconds)
                this.x = this.originalX + (this.targetX - this.originalX) * t; // Move towards target
                this.y = this.originalY + (this.targetY - this.originalY) * t;
                this.size = FIXED_LETTER_SIZE; // Maintain fixed size during animation
                this.alpha = 1; // Full opacity during animation
            } else if (finalDisplayActive) {
                // Permanently fixed in the center after animation
                this.x = this.targetX;
                this.y = this.targetY;
                this.size = FIXED_LETTER_SIZE; // Retain final size
                // Set alpha to 0 if character is an empty string, otherwise 1
                this.alpha = (this.char === '') ? 0 : 1;
            }
            this.vx = 0; this.vy = 0; // Stop any velocity
            return; // Skip normal star movement
        }

        // If the letter is fixed (part of a word)
        if (this.fixed) {
            // Smooth movement to target position
            if (this.targetFixedX !== null && Math.abs(this.x - this.targetFixedX) > 0.5) {
                this.x += (this.targetFixedX - this.x) * 0.15; // Smooth transition speed
            } else if (this.targetFixedX !== null) {
                this.x = this.targetFixedX; // Snap if close enough
                this.targetFixedX = null; // Target reached, reset
            }

            if (this.targetFixedY !== null && Math.abs(this.y - this.targetFixedY) > 0.5) {
                this.y += (this.targetFixedY - this.y) * 0.15; // Smooth transition speed
            } else if (this.targetFixedY !== null) {
                this.y = this.targetFixedY; // Snap if close enough
                this.targetFixedY = null; // Target reached, reset
            }
            return; // Fixed letters do not use other movement logic
        }

        // Current normal star update logic (only for stars that are not finalDisplayStar or ScatteredHeart)
        if (held === this) { // If this star is held by the mouse
          this.x = mouse.x; this.y = mouse.y; // Follow the mouse
          this.vx = this.vy = 0; // Hareketi durdur
          return;
        }
        this.x += this.vx; // Hızı uygula
        this.y += this.vy;
        // Canvas kenarlarından sekme
        if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
        if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.5; }
        if (this.y < 0) { this.y = 0; this.vy *= -0.5; }
        if (this.y > canvas.height) { this.y = canvas.height; this.vy *= -0.5; }
        if (!this.fixed) this.angle += this.spin; // Sabitlenmemişse döndür

        // Fare son zamanlarda hareket ettiyse fareye çekim efekti
        const dt = Date.now() - lastMove;
        if (dt < 2000) { // Fare son 2 saniyede hareket ettiyse
          let dx = mouse.x - this.x;
          let dy = mouse.y - this.y;
          let d = Math.hypot(dx, dy); // Fareye olan uzaklık
          if (d < 150 && held !== this) { // Çekim yarıçapı içindeyse ve tutulmuyorsa
            let s = (150 - d)/150; // Çekim gücü
            this.x += dx*0.05*s; // Fareye doğru hareket et
            this.y += dy*0.05*s;
            this.size = this.baseSize*(1-0.4*s); // Biraz küçül
          }
        } else {
          this.size += (this.baseSize - this.size)*0.1; // Fare etkileşimi yoksa temel boyuta geri dön
        }

        // Bir tuşa basıldığında hızlanma efekti (aynı harfleri fareye doğru çeker)
        for (let k of activeKeys) {
          if (k === this.char) {
            let dur = (Date.now() - keyTimers[k]) / 1000; // Tuşa basılma süresi
            let boost = Math.min(dur, 3); // Maksimum hızlanma
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            this.x += dx*0.01*boost; // Fareye doğru hareket et
            this.y += dy*0.01*boost;
          }
        }
      }
      draw() {
        ctx.save();

        if (this.isBackgroundDot) {
          ctx.translate(this.x, this.y);
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = 'white';
          ctx.shadowColor = 'white';
          ctx.shadowBlur = this.size / 2 + Math.random() * 5; // More varied glow based on size
          ctx.font = this.size + 'px Inter, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(this.char, 0, 0);
          ctx.restore();
          ctx.globalAlpha = 1;
          return;
        }

        if (this.isScatteredHeart) {
            if (this.alpha <= 0) { // Don't draw if completely faded
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = 'white'; // Hearts are white
            ctx.font = this.size + 'px Inter, sans-serif'; // Use current size
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        if (this.isFinalDisplayStar) {
            if (this.char === '' && this.alpha === 0) { // Don't draw fading out parts
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha; // Use current alpha
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white'; ctx.shadowBlur = 8;
            ctx.font = this.size + 'px Inter, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        // Current normal star drawing logic
        // Apply jitter (levitation) effect only if fixed AND not animating a throw
        let lev = (this.fixed && !this.isAnimatingThrow) ? Math.sin(Date.now()/500 + this.x)*1.5 : 0;
        ctx.translate(this.x, this.y + lev); // this.x, this.y are set by the update function
        
        // Eğer sabitlenmemişse VEYA atış animasyonu aktifse döndür
        if (!this.fixed || this.isAnimatingThrow) { 
            ctx.rotate(this.angle);
        }

        if (this.fixed) { // Style for fixed letters (part of a word)
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.3)'; // Semi-transparent black background
          ctx.roundRect(-this.size*0.45, -this.size*0.45, this.size*0.9, this.size*0.9, this.size*0.25);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = 'white'; // White letter
          ctx.shadowColor = 'white'; ctx.shadowBlur = 3; // Slight glow
        } else { // Style for freely floating letters
          ctx.globalAlpha = this.alpha; // Apply transparency
          ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 4; // White letter with stronger glow
        }
        ctx.font = (held===this ? this.size*2 : this.size) + 'px Inter, sans-serif'; // Larger if held
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.char, 0, 0); // Draw the letter
        ctx.restore();
        ctx.globalAlpha = 1; // Reset transparency
      }
    }

    // Shooting Star class (for line lights)
    class ShootingStar {
      constructor() {
        this.size = 2 + Math.random() * 4;
        this.life = 1;
        this.trailLength = 50 + Math.random() * 100; // Length
        this.duration = 2000 + Math.random() * 3000; // Movement duration
        this.startTime = Date.now();
        this.isCurved = false; // Kuyruklu yıldızlar artık sadece doğrusal hareket edecek

        // Start from a random edge and go to a random edge
        const startSide = Math.floor(Math.random() * 4);
        const endSide = Math.floor(Math.random() * 4);

        if (startSide === 0) { // Top
          this.startX = Math.random() * canvas.width;
          this.startY = -this.size;
        } else if (startSide === 1) { // Right
          this.startX = canvas.width + this.size;
          this.startY = Math.random() * canvas.height;
        } else if (startSide === 2) { // Bottom
          this.startX = Math.random() * canvas.width;
          this.startY = canvas.height + this.size;
        } else { // Left
          this.startX = -this.size;
          this.startY = Math.random() * canvas.height;
        }

        if (endSide === 0) { // Top
          this.endX = Math.random() * canvas.width;
          this.endY = -this.size;
        } else if (endSide === 1) { // Right
          this.endX = canvas.width + this.size;
          this.endY = Math.random() * canvas.height;
        } else if (endSide === 2) { // Bottom
          this.endX = Math.random() * canvas.width;
          this.endY = canvas.height + this.size;
        } else { // Left
          this.endX = -this.size;
          this.endY = Math.random() * canvas.height;
        }

        // Control point for curved stars (no longer needed, but keeping for reference, always straight now)
        this.cpX = this.startX; // Initialize cpX and cpY for straight movement
        this.cpY = this.startY;
        
        this.x = this.startX;
        this.y = this.startY;
      }

      update() {
        const elapsed = Date.now() - this.startTime;
        let t = elapsed / this.duration;
        this.life = 1 - t; // Fade out over time

        if (t > 1) {
          this.life = 0;
          return;
        }

        // Artık sadece doğrusal hareket
        this.x = this.startX + (this.endX - this.startX) * t;
        this.y = this.startY + (this.endY - this.startY) * t;
      }

      draw() {
        if (this.life <= 0) return;

        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = this.size * 2;

        // Main point of the shooting star
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // Trail
        // For the trail, we draw a line backward along the velocity vector from the current position.
        // This provides a good visual approximation for straight paths.
        const ratio = this.trailLength / (this.size * 10); // Adjust tail length based on size
        const tailCurrentX = this.x - (this.endX - this.startX) * ratio;
        const tailCurrentY = this.y - (this.endY - this.startY) * ratio;
        
        const gradient = ctx.createLinearGradient(this.x, this.y, tailCurrentX, tailCurrentY);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.size / 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tailCurrentX, tailCurrentY);
        ctx.stroke();

        ctx.restore();
        ctx.globalAlpha = 1;
      }
    }


    // Function to transform selected words into hearts and scatter them (ÇOK and Dynamic Word)
    function transformSelectedWordsToHeartsAndScatter() {
        const shapes = ['❤︎','♡']; // Heart shapes
        let delay = 0;

        // The 2nd index ('ÇOK') and 3rd index (dynamic word) in the allCompletedWordStars array
        const wordsToTransform = [allCompletedWordStars[2], allCompletedWordStars[3]];

        wordsToTransform.forEach(wordStars => {
            if (!wordStars) return; // Safety check if word doesn't exist

            wordStars.forEach(star => {
                setTimeout(() => {
                    star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Transform letter to heart
                    // Emit particles from the transformed heart
                    for (let i = 0; i < 8; i++) {
                        let ang = Math.random()*Math.PI*2;
                        let spd = 1 + Math.random();
                        particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                    }
                    star.isFinalDisplayStar = false; // No longer part of fixed center display
                    star.fixed = false; // Allow it to move
                    star.isScatteredHeart = true; // Mark as a scattered and fading heart
                    star.vx = (Math.random() - 0.5) * 5; // Initial scatter velocity
                    star.vy = (Math.random() - 0.5) * 5;
                    star.alpha = 1; // Start with full opacity
                    star.size = 40; // Maintain large size for hearts
                }, delay);
                delay += 100; // Small delay between letters
            });
            delay += 500; // Larger delay between words
        });
    }

    // Function to remove the "'A" characters at the end of "PINAR'A" word
    function removePinarATail() {
        // The 1st index ("PINAR'A") in the allCompletedWordStars array
        const pinarStars = allCompletedWordStars[1];
        if (pinarStars && pinarStars.length >= 2) {
            const starApostrophe = pinarStars[pinarStars.length - 2];
            const starA = pinarStars[pinarStars.length - 1]; 

            // Clear characters and set alpha to 0
            starApostrophe.char = '';
            starApostrophe.alpha = 0;
            starA.char = '';
            starA.alpha = 0;
        }
    }

    // Function to transform background stars into hearts and scatter them
    function transformBackgroundStarsToHeartsAndScatter() {
        const shapes = ['❤︎','♡'];
        let delay = 0;

        // Filter all stars that are not finalDisplayStar, ScatteredHeart, BackgroundDot, or ConstellationStar
        stars.filter(star => !star.isFinalDisplayStar && !star.isScatteredHeart && !star.isBackgroundDot && !star.isConstellationStar).forEach(star => {
            setTimeout(() => {
                star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Transform letter to heart
                // Emit particles from the transformed heart
                for (let i = 0; i < 8; i++) {
                    let ang = Math.random()*Math.PI*2;
                    let spd = 1 + Math.random();
                    particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                }
                star.fixed = false; // Allow it to move if it was fixed
                star.isScatteredHeart = true; // Mark as a scattered and fading heart
                star.alpha = 1; // Start with full opacity
                star.vx = (Math.random() - 0.5) * 3; // Initial scatter velocity (slightly less)
                star.vy = (Math.random() - 0.5) * 3;
                star.size = 20 + Math.random() * 10; // Give a reasonable size
            }, delay);
            delay += 50; // Gradual delay between background star transformations
        });
    }

    // Helper function to select the closest stars to a specific center
    function selectClosestStars(count, centerX, centerY) {
        // Evaluate only backgroundDots that haven't been selected as constellation stars yet
        const availableStars = backgroundDots.filter(star => !star.isConstellationStar);
        
        const sortedStars = availableStars.sort((a, b) => {
            const distA = Math.hypot(a.x - centerX, a.y - centerY);
            const distB = Math.hypot(b.x - centerX, b.y - centerY);
            return distA - distB;
        });
        return sortedStars.slice(0, count);
    }

    // Function to initiate the final word display animation
    function initiateFinalWordDisplayAnimation() {
        finalDisplayAnimationRunning = true;
        finalDisplayAnimationStartTime = Date.now();
        const animationDuration = 7000; // Animation duration: 7 seconds

        // Determine center positions for constellations
        // Pisces on the left side of the screen, Virgo on the right
        const piscesCenterX = canvas.width * 0.25; 
        const piscesCenterY = canvas.height * 0.5;
        const virgoCenterX = canvas.width * 0.75; 
        const virgoCenterY = canvas.height * 0.5;

        // Select stars for Pisces constellation and assign their targets
        piscesConstellationStars = selectClosestStars(piscesShapeRelative.length, piscesCenterX, piscesCenterY);
        piscesConstellationStars.forEach((star, index) => {
            star.isConstellationStar = true;
            star.originalX = star.x;
            star.originalY = star.y;
            // Offset relative position based on the center
            star.constellationTargetX = piscesCenterX + piscesShapeRelative[index].x;
            star.constellationTargetY = piscesCenterY + piscesShapeRelative[index].y;
        });

        // Select stars for Virgo constellation and assign their targets
        virgoConstellationStars = selectClosestStars(virgoShapeRelative.length, virgoCenterX, virgoCenterY);
        virgoConstellationStars.forEach((star, index) => {
            star.isConstellationStar = true;
            star.originalX = star.x;
            star.originalY = star.y;
            // Offset relative position based on the center
            star.constellationTargetX = virgoCenterX + virgoShapeRelative[index].x;
            star.constellationTargetY = virgoCenterY + virgoShapeRelative[index].y;
        });

        // Record the start time of the constellation formation animation
        constellationFormationStartTime = Date.now();

        const totalWords = allCompletedWordStars.length; // Should be 4 words in total
        const lineHeight = 50; // Vertical spacing for each word line
        const totalDisplayHeight = totalWords * lineHeight;
        const startY = (canvas.height - totalDisplayHeight) / 2; // Starting Y position for the first word

        let minPanelX = canvas.width;
        let maxPanelX = 0;
        let minPanelY = canvas.height;
        let maxPanelY = 0;

        ctx.font = `${FIXED_LETTER_SIZE}px Inter, sans-serif`; // Set correct font for panel size calculation

        // Calculate target positions for each star and determine panel dimensions
        allCompletedWordStars.forEach((wordStars, wordIdx) => {
            // Reconstruct the word from current characters as length might change
            let currentWordString = wordStars.map(s => s.char).join('');
            let wordWidth = ctx.measureText(currentWordString).width;

            const horizontalPadding = 30; // Minimum horizontal padding from screen edges

            let effectiveWordStartX = (canvas.width - wordWidth) / 2; // Try to center

            // If word overflows to the right, shift left
            if (effectiveWordStartX + wordWidth > canvas.width - horizontalPadding) {
                effectiveWordStartX = canvas.width - wordWidth - horizontalPadding;
            }

            // If word overflows to the left (even after previous adjustment), shift right (maintain minimum padding)
            effectiveWordStartX = Math.max(effectiveWordStartX, horizontalPadding);


            wordStars.forEach((star, letterIdx) => {
                star.originalX = star.x; // Store current position as animation start
                star.originalY = star.y;
                star.isFinalDisplayStar = true; // Mark as part of the final display

                // Calculate target X position for each letter within the word
                let accumulatedLetterWidth = 0;
                for(let i = 0; i < letterIdx; i++) {
                    // Accumulate width only for visible characters
                    const prevStar = wordStars[i];
                    if (prevStar.char !== '') {
                        accumulatedLetterWidth += ctx.measureText(prevStar.char).width;
                    }
                }
                star.targetX = effectiveWordStartX + accumulatedLetterWidth + ctx.measureText(star.char).width / 2;

                star.targetY = startY + wordIdx * lineHeight + (lineHeight / 2); // Center vertically on its line

                // Update panel dimensions ONLY for visible characters
                if (star.char !== '') { 
                    minPanelX = Math.min(minPanelX, star.targetX - ctx.measureText(star.char).width / 2);
                    maxPanelX = Math.max(maxPanelX, star.targetX + ctx.measureText(star.char).width / 2);
                    minPanelY = Math.min(minPanelY, star.targetY - lineHeight / 2);
                    maxPanelY = Math.max(maxPanelY, star.targetY + lineHeight / 2);
                }
            });
        });

        const paddingX = 60;
        const paddingY = 40;

        let calculatedContentWidth = maxPanelX - minPanelX;
        let calculatedContentHeight = maxPanelY - minPanelY;

        // If no visible words were processed (or min/max resulted in invalid range),
        // set default minimum dimensions for the panel.
        if (calculatedContentWidth <= 0 || allCompletedWordStars.length === 0) {
            panelRect.width = 200 + paddingX; // Default reasonable width
            panelRect.x = (canvas.width - panelRect.width) / 2; // Center the default panel
        } else {
            panelRect.width = calculatedContentWidth + paddingX;
            panelRect.x = minPanelX - paddingX / 2;
        }

        if (calculatedContentHeight <= 0 || allCompletedWordStars.length === 0) {
            panelRect.height = 100 + paddingY; // Default reasonable height
            panelRect.y = (canvas.height - panelRect.height) / 2; // Center the default panel
        } else {
            panelRect.height = calculatedContentHeight + paddingY;
            panelRect.y = minPanelY - paddingY / 2;
        }

        // Ensure panelRect stays within canvas boundaries (existing logic)
        panelRect.x = Math.max(0, panelRect.x);
        panelRect.y = Math.max(0, panelRect.y);
        if (panelRect.x + panelRect.width > canvas.width) {
            panelRect.width = canvas.width - panelRect.x;
        }
        if (panelRect.y + panelRect.height > canvas.height) {
            panelRect.height = canvas.height - panelRect.y;
        }

        // Plan the end of the animation and transition to static display + transformation
        setTimeout(() => {
            finalDisplayAnimationRunning = false;
            finalDisplayActive = true; // Words are now permanently fixed in the center

            // Apply transformations for words (ÇOK, dynamic) and PINAR'A
            transformSelectedWordsToHeartsAndScatter();
            removePinarATail();

            // Start background stars transformation shortly after word transformations begin
            setTimeout(() => {
                transformBackgroundStarsToHeartsAndScatter();
            }, 1500); // Wait 1.5 seconds after word transformations start
        }, animationDuration);
    }

    // Boomerang throw function (only animates the star and physically fixes it)
    function bumerangFırlat(star, onCompleteCallback) {
      star.isAnimatingThrow = true; // Set flag to true when animation starts
      const sx = star.x, sy = star.y;
      const mdx = mouse.mx, mdy = mouse.my;
      const speed = Math.hypot(mdx, mdy);
      const ang = Math.atan2(mdy, mdx);
      const dist = Math.min(200 + speed*15, 800);
      const ox = sx + Math.cos(ang)*dist, oy = sy + Math.sin(ang)*dist;

      let tx, ty;
      if (fixedLetters.length === 0) { tx = ox; ty = oy; }
      else { let last = fixedLetters[fixedLetters.length - 1]; tx = last.x + 36; ty = last.y; }

      const fd = Math.hypot(ox - sx, oy - sy);
      const bd = Math.hypot(tx - ox, ty - oy);
      const tot = fd + bd;
      const dur = 4500;
      const ft = fd / tot * dur;
      const bt = dur - ft;
      const mx1 = (sx + ox) / 2 + 60, my1 = (sy + oy) / 2 - 60;
      const mx2 = (ox + tx) / 2 + 60, my2 = (oy + ty) / 2 - 60;
      const start = Date.now(), ia = star.angle;

      function step() {
        let e = Date.now() - start;
        if (e > dur) e = dur;
        const t = e / dur;
        
        // Harf, hedefe doğru düzgün bir şekilde döner
        star.angle = ia * (1 - t); // Başlangıç açısıdan 0'a (düz) doğru yumuşak geçiş

        let cx, cy;
        if (e <= ft) {
          const p = e / ft;
          const a = (1 - p) ** 2, b = 2 * (1 - p) * p, c = p ** 2;
          cx = a * sx + b * mx1 + c * ox;
          cy = a * sy + b * my1 + c * oy;
        } else {
          const p = (e - ft) / bt;
          const a = (1 - p) ** 2, b = 2 * (1 - p) * p, c = p ** 2;
          cx = a * ox + b * mx2 + c * tx;
          cy = a * oy + b * my2 + c * ty;
        }
        star.x = cx; star.y = cy;
        star.size = star.baseSize + (FIXED_LETTER_SIZE - star.baseSize) * t;

        if (e < dur) {
          requestAnimationFrame(step);
        } else {
          star.x = tx; star.y = ty;
          star.size = FIXED_LETTER_SIZE;
          star.wordIndex = wordIndex;
          star.isAnimatingThrow = false; // Set flag to false when animation ends

          if (onCompleteCallback) {
            onCompleteCallback(star);
          }
        }
      }
      step();
    }

    // Recalculates and applies target positions for all fixed letters
    function recalculateFixedLetterPositions() {
      const letterPadding = 36;
      ctx.font = `${FIXED_LETTER_SIZE}px Inter, sans-serif`; // Set correct font for text measurements

      let totalCurrentWordWidth = 0;
      for (let i = 0; i < fixedLetters.length; i++) {
          totalCurrentWordWidth += ctx.measureText(fixedLetters[i].char).width;
          if (i < fixedLetters.length - 1) {
              totalCurrentWordWidth += letterPadding;
          }
      }

      const minScreenPadding = 30; // Minimum horizontal padding from screen edges
      const verticalWordSpacing = 60; // Vertical spacing between different completed words
      const fixedLetterHeight = FIXED_LETTER_SIZE; // Approximate height of a fixed letter (for vertical spacing)

      let currentWordBlockY;
      if (fixedLetters.length === 1) {
          // If this is the first letter, use its current Y position (it will be the landing spot)
          currentWordBlockY = fixedLetters[0].y;
      } else {
          // For subsequent letters, derive the word's Y position from the first fixed letter's target Y or current Y
          currentWordBlockY = fixedLetters[0].targetFixedY !== null ? fixedLetters[0].targetFixedY : fixedLetters[0].y;
      }

      for (const completedWordStars of allCompletedWordStars) {
          if (completedWordStars.length > 0) {
              const completedWordFirstStar = completedWordStars[0];
              const completedWordCenterY = completedWordFirstStar.targetFixedY !== null ? completedWordFirstStar.targetFixedY : completedWordFirstStar.y;

              const completedWordTop = completedWordCenterY - (fixedLetterHeight / 2);
              const completedWordBottom = completedWordCenterY + (fixedLetterHeight / 2);

              const currentWordTop = currentWordBlockY - (fixedLetterHeight / 2);
              const currentWordBottom = currentWordBlockY + (fixedLetterHeight / 2);

              if (currentWordTop < completedWordBottom && currentWordBottom > completedWordTop) {
                  currentWordBlockY = completedWordBottom + (fixedLetterHeight / 2) + verticalWordSpacing;
              }
          }
      }

      currentWordBlockY = Math.max(minScreenPadding + fixedLetterHeight / 2, currentWordBlockY);
      currentWordBlockY = Math.min(canvas.height - minScreenPadding - fixedLetterHeight / 2, currentWordBlockY);

      let currentWordBlockStartX;
      if (fixedLetters.length === 1) {
          currentWordBlockStartX = fixedLetters[0].x - (ctx.measureText(fixedLetters[0].char).width / 2);
      } else {
          currentWordBlockStartX = fixedLetters[0].targetFixedX !== null ? fixedLetters[0].targetFixedX - (ctx.measureText(fixedLetters[0].char).width / 2) : fixedLetters[0].x - (ctx.measureText(fixedLetters[0].char).width / 2);
      }

      if (currentWordBlockStartX + totalCurrentWordWidth > canvas.width - minScreenPadding) {
          currentWordBlockStartX = canvas.width - totalCurrentWordWidth - minScreenPadding;
      }
      currentWordBlockStartX = Math.max(minScreenPadding, currentWordBlockStartX);

      let currentPlacementWidth = 0;
      for (let i = 0; i < fixedLetters.length; i++) {
          const fLetter = fixedLetters[i];
          const charWidth = ctx.measureText(fLetter.char).width;
          fLetter.targetFixedX = currentWordBlockStartX + currentPlacementWidth + (charWidth / 2);
          fLetter.targetFixedY = currentWordBlockY;
          currentPlacementWidth += charWidth;
          if (i < fixedLetters.length - 1) {
              currentPlacementWidth += letterPadding;
          }
      }
    }

    // Checks if the current word is completed and transitions to the next phase
    function checkWordCompletion() {
      let wordCompleted = false;

      if (currentWord === 'ÇOK') {
          // 'K' is placed when 'ÇOK' is completed, meaning currentIndex is 2.
          if (currentIndex === 2) {
              wordCompleted = true;
          }
      } else if (currentWord && !dynamicMode) { // For ALTAY, PINAR'A, and selected dynamic word (not in selection phase)
          if (currentIndex >= currentWord.length) {
              wordCompleted = true;
          }
      }

      if (wordCompleted) {
          allCompletedWordStars.push([...fixedLetters]);
          fixedLetters = []; // Clear letters for the next word

          if (currentWord === 'ÇOK') { // Transition from 'ÇOK' to dynamic word selection
              dynamicMode = true;
              currentWord = ''; // Clear currentWord to signify dynamic selection phase
              currentIndex = 0; // Reset for dynamic word's first character selection
              secondPhase = false;
          } else if (wordIndex < wordList.length - 1) { // Move to the next predefined word
              wordIndex++;
              currentWord = wordList[wordIndex];
              currentIndex = 0;
          } else { // All words (predefined + dynamic) are completed
              initiateFinalWordDisplayAnimation();
          }
      }
    }

    // Function to create an exploding heart group
    function createExplodingHeartGroup() {
      const numHearts = 2 + Math.floor(Math.random() * 2); // 2 or 3 hearts
      const startX = Math.random() * canvas.width;
      const startY = Math.random() * canvas.height;
      const heartShapes = ['❤︎', '♡'];

      for (let i = 0; i < numHearts; i++) {
        const heart = new Star(heartShapes[Math.floor(Math.random() * heartShapes.length)]);
        heart.x = startX + (Math.random() - 0.5) * 20; // Slightly offset
        heart.y = startY + (Math.random() - 0.5) * 20;
        heart.fixed = false;
        heart.isScatteredHeart = true; // Ensure it scatters and fades
        heart.alpha = 1;
        heart.size = 20 + Math.random() * 15; // Varying size
        heart.vx = (Math.random() - 0.5) * 4; // Initial outward velocity
        heart.vy = (Math.random() - 0.5) * 4;
        stars.push(heart); // Add to main stars array (to be updated and drawn)
      }
    }

    // Function to reset the game
    function reset() {
      stars=[];
      for(let i=0;i<120;i++) stars.push(new Star()); // Normal stars

      // Initialize background dots
      backgroundDots = [];
      for(let i=0; i<500; i++) { // Create 500 background dots for more density
        const dot = new Star('•'); // Create a new Star with '•' character
        // Background dots are already created within canvas boundaries at the start.
        // Their positions are randomly determined within canvas width and height.
        dot.x = Math.random() * canvas.width;
        dot.y = Math.random() * canvas.height;
        backgroundDots.push(dot);
      }

      particles=[];
      shootingStars=[]; // Clear shooting stars
      fixedLetters=[];
      wordIndex=0; currentWord=wordList[0]; currentIndex=0;
      dynamicMode=false; secondPhase=false;
      // Reset constellation variables
      piscesConstellationStars = [];
      virgoConstellationStars = [];
      constellationFormationStartTime = 0;

      // Reset new global variables
      allCompletedWordStars = [];
      finalDisplayAnimationRunning = false;
      finalDisplayAnimationStartTime = 0;
      finalDisplayActive = false;
      panelRect = { x: 0, y: 0, width: 0, height: 0 }; // Reset panel
    }
    reset(); // Initialize game on load

    // Helper function to update mouse/touch event coordinates
    function updateMouseCoordinates(clientX, clientY) {
      mouse.px = mouse.x;
      mouse.py = mouse.y;
      mouse.x = clientX;
      mouse.y = clientY;
      lastMove = Date.now();
      mouse.mx = mouse.x - mouse.px;
      mouse.my = mouse.y - mouse.py;

      const dx = mouse.px - mouse.x;
      const dy = mouse.py - mouse.y;
      const m = Math.hypot(dx, dy);
      if (m > 1) {
        for (let i = 0; i < 3; i++) {
          particles.push(new Particle(
            mouse.x, mouse.y,
            dx * 0.02 + (Math.random() - 0.5) * 1.5, // Increased value for more angular emission
            dy * 0.02 + (Math.random() - 0.5) * 2 // Increased value for more angular emission
          ));
        }
      }
    }

    // Mouse Event Listeners
    window.addEventListener('mousemove', e => {
      updateMouseCoordinates(e.clientX, e.clientY);
    });

    window.addEventListener('mousedown', ()=>{
      for(let s of stars) {
        const dx = s.x - mouse.x;
        const dy = s.y - mouse.y;
        // Only allow holding stars that are not fixed and not currently animating a throw
        if (Math.hypot(dx, dy) < 20 && !s.fixed && !s.isAnimatingThrow) {
          held = s;
          break;
        }
      }
    });

    window.addEventListener('mouseup', ()=>{
      if (!held) return;

      // Prevent interaction if words are in final static display or during animation
      if (finalDisplayActive || finalDisplayAnimationRunning) {
          held = null;
          return;
      }

      const charThrown = held.char;
      const thrownStar = held;
      
      if (dynamicMode) {
        if (!secondPhase) { // Selecting the first letter of the dynamic word
          options = wordGroups[charThrown] || [];
          if (options.length > 0) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star); // Add to fixedLetters
                if (options.length > 1) {
                    secondPhase = true;
                    currentIndex = 1; // First character of the dynamic word is selected
                } else {
                    currentWord = options[0];
                    dynamicMode = false;
                    currentIndex = 1; // First character of the actual dynamic word (e.g., AŞIK)
                }
                recalculateFixedLetterPositions(); // Recalculate positions after adding
                checkWordCompletion(); // Check for completion after adding
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3; // Release if not valid
            thrownStar.fixed = false; // Ensure it's not fixed
          }
        } else { // secondPhase
          const match = options.find(w => w[1] === charThrown);
          if (match) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star); // Add to fixedLetters
                currentWord = match;
                secondPhase = false;
                dynamicMode = false;
                currentIndex = 2; // Second character of the actual dynamic word
                recalculateFixedLetterPositions(); // Recalculate positions after adding
                checkWordCompletion(); // Check for completion after adding
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3; // Release if not valid
            thrownStar.fixed = false; // Ensure it's not fixed
          }
        }
      } else { // Predefined words (ALTAY, PINAR'A, ÇOK)
        let shouldAccept = false;
        let shouldIncrement = false;

        const expectedCharForCurrentIndex = currentWord[currentIndex];

        if (currentWord === 'ÇOK') {
            if (currentIndex === 0 && charThrown === 'Ç') {
                shouldAccept = true;
                shouldIncrement = true;
            } else if (currentIndex === 1 && charThrown === 'O') {
                shouldAccept = true;
                shouldIncrement = false; // Do not increment index for multiple 'O's
            } else if (currentIndex === 1 && charThrown === 'K') {
                shouldAccept = true;
                shouldIncrement = true;
            }
        } else { // For ALTAY, PINAR'A
            if (charThrown === expectedCharForCurrentIndex) {
                shouldAccept = true;
                shouldIncrement = true;
            }
        }

        if (shouldAccept) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star);
                if (shouldIncrement) {
                    currentIndex++;
                }
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
        } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
        }
      }
      held = null; // Ensure held is always null after mouseup
    });


    // Touch Event Listeners (Added)
    window.addEventListener('touchstart', e => {
      e.preventDefault(); // Prevent default touch behavior (scrolling, zooming)
      if (e.touches.length > 0) {
        updateMouseCoordinates(e.touches[0].clientX, e.touches[0].clientY);
        for(let s of stars) {
          const dx = s.x - mouse.x;
          const dy = s.y - mouse.y;
          // Only allow holding stars that are not fixed and not currently animating a throw
          if (Math.hypot(dx, dy) < 40 && !s.fixed && !s.isAnimatingThrow) { // Slightly larger area for touch
            held = s;
            break;
          }
        }
      }
    });

    window.addEventListener('touchmove', e => {
      e.preventDefault(); // Prevent default touch behavior
      if (e.touches.length > 0) {
        updateMouseCoordinates(e.touches[0].clientX, e.touches[0].clientY);
      }
    });

    window.addEventListener('touchend', e => {
      e.preventDefault(); // Prevent default touch behavior
      // Use the same logic as mouseup for touchend event
      if (!held) return;

      // Prevent interaction if words are in final static display or during animation
      if (finalDisplayActive || finalDisplayAnimationRunning) {
          held = null;
          return;
      }

      const charThrown = held.char;
      const thrownStar = held;
      
      if (dynamicMode) {
        if (!secondPhase) {
          options = wordGroups[charThrown] || [];
          if (options.length > 0) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                if (options.length > 1) {
                    secondPhase = true;
                    currentIndex = 1;
                } else {
                    currentWord = options[0];
                    dynamicMode = false;
                    currentIndex = 1;
                }
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
          }
        } else {
          const match = options.find(w => w[1] === charThrown);
          if (match) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                currentWord = match;
                secondPhase = false;
                dynamicMode = false;
                currentIndex = 2;
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
          }
        }
      } else {
        let shouldAccept = false;
        let shouldIncrement = false;

        const expectedCharForCurrentIndex = currentWord[currentIndex];

        if (currentWord === 'ÇOK') {
            if (currentIndex === 0 && charThrown === 'Ç') {
                shouldAccept = true;
                shouldIncrement = true;
            } else if (currentIndex === 1 && charThrown === 'O') {
                shouldAccept = true;
                shouldIncrement = false;
            } else if (currentIndex === 1 && charThrown === 'K') {
                shouldAccept = true;
                shouldIncrement = true;
            }
        } else {
            if (charThrown === expectedCharForCurrentIndex) {
                shouldAccept = true;
                shouldIncrement = true;
            }
        }

        if (shouldAccept) {
            thrownStar.fixed = true; // Letter is fixed immediately.
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                if (shouldIncrement) {
                    currentIndex++;
                }
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
        } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
        }
      }
      held = null; // Ensure held is always null after touchend
    });

    // Keyboard event listeners (add stars on key press and reset on Spacebar)
    window.addEventListener('keydown', e => {
      // Reset game with Spacebar
      if (e.code === 'Space') {
        reset();
        return;
      }
      // Skip to end game with '7' key
      if (e.key === '7') {
          // Set wordIndex to ensure all words are considered "completed" for final display
          wordIndex = wordList.length - 1; // Last predefined word
          // Manually populate allCompletedWordStars for demonstration if not already done
          if (allCompletedWordStars.length < wordList.length) {
              // Clear existing fixedLetters if any for current word
              fixedLetters = [];
              // Add dummy completed words to simulate full progression
              // This part might need refinement to exactly match game state
              // but serves the purpose of enabling final animation
              if (allCompletedWordStars.length === 0) { // If nothing completed yet, add all words
                  allCompletedWordStars.push(
                      wordList[0].split('').map(char => new Star(char)), // ALTAY
                      wordList[1].split('').map(char => new Star(char)), // PINAR'A
                      wordList[2].split('').map(char => new Star(char)), // ÇOK
                      "AŞIK".split('').map(char => new Star(char)) // Example dynamic word
                  );
                  // Ensure dummy stars have a basic position for calculation purposes, though they will animate away
                  allCompletedWordStars.flat().forEach(star => {
                    star.x = Math.random() * canvas.width;
                    star.y = Math.random() * canvas.height;
                  });
              }
          }
          initiateFinalWordDisplayAnimation();
          return;
      }

      const k = e.key.toUpperCase();
      if (letters.includes(k) && !activeKeys.has(k)) {
        keyTimers[k] = Date.now();
        activeKeys.add(k);
        // Add a new star when a key is pressed
        stars.push(new Star(k));
      }
    });

    window.addEventListener('keyup', e => {
      const k = e.key.toUpperCase();
      if (activeKeys.has(k)) {
        delete keyTimers[k];
        activeKeys.delete(k);
      }
    });

    // Helper function to draw constellation lines
    function drawConstellationLines(constellationStars, connections) {
      if (!finalDisplayActive) return; // Only draw when final display is active

      ctx.save();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Light glowing white line
      ctx.lineWidth = 1;
      ctx.shadowColor = 'white';
      ctx.shadowBlur = 5; // Slight glow effect

      connections.forEach(conn => {
        const fromStar = constellationStars[conn[0]];
        const toStar = constellationStars[conn[1]];
        if (fromStar && toStar) {
          ctx.beginPath();
          ctx.moveTo(fromStar.x, fromStar.y);
          ctx.lineTo(toStar.x, toStar.y);
          ctx.stroke();
        }
      });
      ctx.restore();
    }


    // Main animation loop
    let lastExplodingHeartTime = 0;
    let lastShootingStarTime = 0;
    const explodingHeartInterval = 1000; // Exploding heart group every 1 second
    const shootingStarInterval = 2000; // Shooting star every 2 seconds

    function animate() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // Clear the entire canvas

      // Draw background dots first
      backgroundDots.forEach(d => { d.update(); d.draw(); }); // Constellation stars are also updated and drawn here

      // Draw panel if words are in final display or during animation
      if (finalDisplayAnimationRunning || finalDisplayActive) {
          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Semi-transparent black
          ctx.roundRect(panelRect.x, panelRect.y, panelRect.width, panelRect.height, panelRadius);
          ctx.fill();
          ctx.restore(); // Restore context (remove shadow from other drawings)
      }

      // Particles are always drawn
      particles.forEach(p=>{ p.update(); p.draw(); });
      particles = particles.filter(p=>p.life>0);

      // Stars (letters) are always drawn
      stars.forEach(s=>{ s.update(); s.draw(); }); // Star.update and Star.draw now handle isScatteredHeart and isFinalDisplayStar logic

      // Update and draw shooting stars
      shootingStars.forEach(ss => { ss.update(); ss.draw(); });
      shootingStars = shootingStars.filter(ss => ss.life > 0);

      // Trigger new effects when finalDisplayActive is true
      if (finalDisplayActive) {
        const currentTime = Date.now();
        // Exploding hearts
        if (currentTime - lastExplodingHeartTime > explodingHeartInterval) {
          createExplodingHeartGroup();
          lastExplodingHeartTime = currentTime;
        }
        // Shooting stars
        if (currentTime - lastShootingStarTime > shootingStarInterval) {
          shootingStars.push(new ShootingStar());
          lastShootingStarTime = currentTime;
        }
        // Draw constellation lines
        drawConstellationLines(piscesConstellationStars, piscesConnections);
        drawConstellationLines(virgoConstellationStars, virgoConnections);
      }

      requestAnimationFrame(animate); // Request the next animation frame
    }
    animate(); // Start the animation loop
  </script>
</body>
<audio id="bg-music" autoplay loop>
  <source src="stars-will-align.mp3" type="audio/mpeg">
  Tarayıcınız bu ses dosyasını desteklemiyor.
</audio>

<script>
  window.addEventListener('click', function () {
    const music = document.getElementById('bg-music');
    if (music && music.paused) {
      music.play().catch(e => console.log("Müzik oynatılamadı:", e));
    }
  }, { once: true });
</script>
</html>
