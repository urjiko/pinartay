<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harfli Uzay Oyunu</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; cursor: none; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="space"></canvas>
  <script>
    // Canvas kurulumu
    const canvas = document.getElementById('space');
    const ctx = canvas.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // Yuvarlak dikdörtgen çizimi için CanvasRenderingContext2D prototipine eklenen fonksiyon
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2*r) r = w/2;
      if (h < 2*r) r = h/2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arcTo(x + w, y, x + w, y + r, r);
      this.lineTo(x + w, y + h - r);
      this.arcTo(x + w, y + h, x + w - r, y + h, r);
      this.lineTo(x + r, y + h);
      this.arcTo(x, y + h, x, y + h - r, r);
      this.lineTo(x, y + r);
      this.arcTo(x, y, x + r, y, r);
      this.closePath();
    };

    // Global oyun durumu değişkenleri
    const letters = "ABCDEFGHIJKLMNOPRSTUVYZ'ÇÖÜİĞŞ".split(''); // Kullanılacak harfler
    let particles = []; // Fare hareket ettiğinde görsel efektler için parçacıklar
    let stars = [];     // Uzayda yüzen harfler (yıldızlar)
    let fixedLetters = []; // Bir kelime oluşturmak için yerleştirilmiş harfler
    let held = null;    // Fare tarafından sürüklenen mevcut harf/yıldız
    let mouse = { x:0, y:0, px:0, py:0, mx:0, my:0 }; // Fare pozisyonu ve hareketi
    let lastMove = Date.now(); // Son fare hareketinin zaman damgası
    let keyTimers = {}; // Bir tuşun ne kadar süre basılı tutulduğunu izlemek için
    let activeKeys = new Set(); // Şu anda basılı olan tuşlar

    // Yeni eklenen global değişkenler (kelimelerin son konumda gösterimi ve animasyonu için)
    let allCompletedWordStars = [];      // Tamamlanmış her kelime için Star objelerinin dizilerini saklar
    let finalDisplayAnimationRunning = false; // 10 saniyelik kaydırma animasyonu sırasında true
    let finalDisplayAnimationStartTime = 0;   // Son gösterim animasyonunun başladığı zaman damgası
    let finalDisplayActive = false;       // Kelimeler ortada kalıcı olarak sabitlendiğinde true

    // Arka plan paneli için yeni global değişkenler
    let panelRect = { x: 0, y: 0, width: 0, height: 0 };
    let panelRadius = 20; // Panel köşelerinin yuvarlaklık yarıçapı


    // Oyun ilerlemesi için kelime listeleri
    const wordList = ["ALTAY","PINAR'A","ÇOK"]; // Önceden tanımlanmış kelimeler
    const wordGroups = { // Dinamik kelime için ilk seçilen harfe göre seçenekler
      A:["AŞIK","AZIYOR"], Ö:["ÖLÜYOR"], B:["BİTİYOR"], E:["ERİYOR"],
      Y:["YÜKSELİYOR"], T:["TAPIYOR"], H:["HAYRAN"],
      C:["COŞUYOR"], Ç:["ÇABALADI"], D:["DELİRİYOR"], F:["FETİŞ"], G:["GÜLÜYOR"],
      I:["ISLAK"], İ:["İSTEKLİ"], K:["KALP"], L:["LOVE"], M:["MÜPTELA"],
      N:["NİYETLİ"], O:["OKŞUYOR"], P:["PSPSPS"], R:["RAZI"],
      S:["SEVİŞİYOR"], Ş:["ŞEHVETLİ"], U:["UYAR"], Ü:["ÜLFET"],
      V:["VAKUM"], Z:["ZİMMETLİ"]
    };
    let wordIndex = 0;      // Önceden tanımlanmış kelime listesindeki mevcut indeks
    let currentWord = wordList[wordIndex]; // Şu anda oluşturulan kelime
    let currentIndex = 0;   // currentWord içindeki mevcut harf indeksi
    let dynamicMode = false; // Dinamik kelimenin ilk harfini seçerken true
    let options = [];        // İlk harf seçiminden sonra olası dinamik kelimeler
    let secondPhase = false; // Dinamik kelimenin ikinci harfini seçerken true (birden fazla seçenek varsa)

    // Parçacık sınıfı (görsel efektler için)
    class Particle {
      constructor(x,y,vx,vy) {
        this.x=x; this.y=y; // Pozisyon
        this.vx=vx; this.vy=vy; // Hız
        this.life=1; // Ömür döngüsü (zamanla azalır)
      }
      update() {
        this.x += this.vx; this.y += this.vy; // Parçacığı hareket ettir
        this.life -= 0.02; // Ömrü azalt
      }
      draw() {
        if (this.life <= 0.1) return; // Neredeyse yoksa çizme
        ctx.globalAlpha = this.life; // Ömrüne göre şeffaflaştır
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2); // Küçük beyaz bir daire çiz
        ctx.fill();
        ctx.globalAlpha = 1; // Şeffaflığı sıfırla
      }
    }

    // Yıldız (Harf) sınıfı
    class Star {
      constructor(c) {
        this.char = c || letters[Math.floor(Math.random()*letters.length)]; // Rastgele bir harf veya belirtilen bir harf ata
        this.x = Math.random()*canvas.width; // Rastgele başlangıç X pozisyonu
        this.y = Math.random()*canvas.height; // Rastgele başlangıç Y pozisyonu
        this.vx = (Math.random()-0.5)*0.3; // Rastgele başlangıç X hızı
        this.vy = (Math.random()-0.5)*0.3; // Rastgele başlangıç Y hızı
        this.baseSize = 14 + Math.random()*8; // Temel yazı tipi boyutu
        this.size = this.baseSize; // Mevcut yazı tipi boyutu
        this.alpha = 0.3 + Math.random()*0.7; // Şeffaflık
        this.angle = Math.random()*Math.PI*2; // Başlangıç dönüş açısı
        this.spin = (Math.random()-0.5)*0.01; // Dönüş hızı
        this.fixed = false; // Harf, tamamlanmış bir kelimenin parçasıysa true
        this.wordIndex = wordIndex; // Bu yıldızın ait olduğu kelime indeksi (kalp dönüşümü için kullanışlı)

        // Son gösterim animasyonu ve dağılma için yeni özellikler
        this.originalX = this.x;
        this.originalY = this.y;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isFinalDisplayStar = false; // Son ortalanmış gösterimin parçası olacak yıldızları işaretlemek için bayrak
        this.isScatteredHeart = false;   // Dağılan kalp olarak işaretlemek için bayrak
      }
      update() {
        // Eğer bu yıldız dağılan bir kalp ise, benzersiz güncelleme mantığını uygula
        if (this.isScatteredHeart) {
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98; // Sönümleme
            this.vy *= 0.98; // Sönümleme
            this.alpha -= 0.003; // Yavaşça soluklaş
            if (this.alpha <= 0) {
                // Tamamen soluklaştığında yıldızı global stars dizisinden kaldır
                const index = stars.indexOf(this);
                if (index > -1) {
                    stars.splice(index, 1);
                }
            }
            return; // Diğer güncelleme mantığını atla
        }

        // Eğer bu yıldız son, sabit gösterimin bir parçasıysa (ALTAY, PINAR veya kaybolan 'A)
        if (this.isFinalDisplayStar) {
            if (finalDisplayAnimationRunning) {
                let elapsed = Date.now() - finalDisplayAnimationStartTime;
                let t = Math.min(1, elapsed / 10000); // Süreyi 0-1 aralığında normalleştir (10 saniye boyunca)
                this.x = this.originalX + (this.targetX - this.originalX) * t; // Hedefe doğru hareket ettir
                this.y = this.originalY + (this.targetY - this.originalY) * t;
                this.size = this.baseSize + (40 - this.baseSize) * t; // Animasyon sırasında boyutu büyüt
                this.alpha = 1; // Animasyon sırasında tam opaklık
            } else if (finalDisplayActive) {
                // Animasyondan sonra ortada kalıcı olarak sabitlenmiş
                this.x = this.targetX;
                this.y = this.targetY;
                this.size = 40; // Son boyutu koru
                // Karakter boş string ise alpha 0 yap, aksi takdirde 1
                this.alpha = (this.char === '') ? 0 : 1;
            }
            this.vx = 0; this.vy = 0; // Herhangi bir hızı durdur
            return; // Normal yıldız hareketini atla
        }

        // Mevcut normal yıldız güncelleme mantığı (yalnızca finalDisplayStar veya ScatteredHeart olmayan yıldızlar için)
        if (this.fixed) return; // Sabitlenmiş harfler hareket etmez
        if (held === this) { // Eğer bu yıldız fare tarafından tutuluyorsa
          this.x = mouse.x; this.y = mouse.y; // Fareyi takip et
          this.vx = this.vy = 0; // Hareketi durdur
          return;
        }
        this.x += this.vx; // Hızı uygula
        this.y += this.vy;
        // Canvas kenarlarından sekme
        if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
        if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.5; }
        if (this.y < 0) { this.y = 0; this.vy *= -0.5; }
        if (this.y > canvas.height) { this.y = canvas.height; this.vy *= -0.5; }
        if (!this.fixed) this.angle += this.spin; // Sabitlenmemişse döndür

        // Fare hareket ettiyse fareye doğru çekim etkisi
        const dt = Date.now() - lastMove;
        if (dt < 2000) { // Fare son 2 saniye içinde hareket ettiyse
          let dx = mouse.x - this.x;
          let dy = mouse.y - this.y;
          let d = Math.hypot(dx, dy); // Fareye olan uzaklık
          if (d < 150 && held !== this) { // Çekim yarıçapı içindeyse ve tutulmuyorsa
            let s = (150 - d)/150; // Çekim gücü
            this.x += dx*0.05*s; // Fareye doğru hareket et
            this.y += dy*0.05*s;
            this.size = this.baseSize*(1-0.4*s); // Biraz küçült
          }
        } else {
          this.size += (this.baseSize - this.size)*0.1; // Fare etkileşimi yoksa temel boyutuna dön
        }

        // Bir tuşa basıldığında hızlandırma etkisi (aynı harfleri fareye doğru çeker)
        for (let k of activeKeys) {
          if (k === this.char) {
            let dur = (Date.now() - keyTimers[k]) / 1000; // Tuşun basılı kalma süresi
            let boost = Math.min(dur, 3); // Maksimum hızlandırma
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            this.x += dx*0.01*boost; // Fareye doğru hareket et
            this.y += dy*0.01*boost;
          }
        }
      }
      draw() {
        ctx.save();

        if (this.isScatteredHeart) {
            if (this.alpha <= 0) { // Tamamen soluklaştıysa çizme
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = 'white'; // Kalpler beyaz
            ctx.font = this.size + 'px Inter, sans-serif'; // Mevcut boyutunu kullan
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        if (this.isFinalDisplayStar) {
            if (this.char === '' && this.alpha === 0) { // Kaybolan kısımları çizme
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha; // Mevcut alpha değerini kullan
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white'; ctx.shadowBlur = 8;
            ctx.font = this.size + 'px Inter, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        // Mevcut normal yıldız çizim mantığı
        let lev = this.fixed ? Math.sin(Date.now()/500 + this.x)*1.5 : 0; // Sabitlenmiş harfler için hafif dalgalanma efekti
        ctx.translate(this.x, this.y + lev);
        if (!this.fixed) ctx.rotate(this.angle); // Sabitlenmemişse döndür
        if (this.fixed) { // Sabitlenmiş harfler için stil (bir kelimenin parçası)
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.3)'; // Yarı şeffaf siyah arka plan
          ctx.roundRect(-this.size*0.45, -this.size*0.45, this.size*0.9, this.size*0.9, this.size*0.25);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = 'white'; // Beyaz harf
          ctx.shadowColor = 'white'; ctx.shadowBlur = 3; // Hafif parlama
        } else { // Serbest yüzen harfler için stil
          ctx.globalAlpha = this.alpha; // Şeffaflığı uygula
          ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 4; // Daha güçlü parlamalı beyaz harf
        }
        ctx.font = (held===this ? this.size*2 : this.size) + 'px Inter, sans-serif'; // Tutuluyorsa daha büyük
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.char, 0, 0); // Harfi çiz
        ctx.restore();
        ctx.globalAlpha = 1; // Şeffaflığı sıfırla
      }
    }

    // Seçili kelimeleri kalplere dönüştüren ve dağıtan fonksiyon (ÇOK ve Dinamik Kelime)
    function transformSelectedWordsToHeartsAndScatter() {
        const shapes = ['❤︎','♡']; // Kalp şekilleri
        let delay = 0;

        // allCompletedWordStars dizisinde 2. indeks ('ÇOK') ve 3. indeks (dinamik kelime)
        const wordsToTransform = [allCompletedWordStars[2], allCompletedWordStars[3]];

        wordsToTransform.forEach(wordStars => {
            if (!wordStars) return; // Kelime yoksa güvenlik kontrolü

            wordStars.forEach(star => {
                setTimeout(() => {
                    star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Harfi kalbe dönüştür
                    // Dönüşen kalpten parçacıklar yay
                    for (let i = 0; i < 8; i++) {
                        let ang = Math.random()*Math.PI*2;
                        let spd = 1 + Math.random();
                        particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                    }
                    star.isFinalDisplayStar = false; // Artık sabit merkezi gösterimin parçası değil
                    star.fixed = false; // Hareket etmesine izin ver
                    star.isScatteredHeart = true; // Dağılan ve soluklaşan kalp olarak işaretle
                    star.vx = (Math.random() - 0.5) * 5; // Başlangıç dağılma hızı
                    star.vy = (Math.random() - 0.5) * 5;
                    star.alpha = 1; // Tam opak başla
                    star.size = 40; // Kalpler için büyük boyutu koru
                }, delay);
                delay += 100; // Harfler arasında küçük gecikme
            });
            delay += 500; // Kelimeler arasında daha büyük gecikme
        });
    }

    // "PINAR'A" kelimesinin sonundaki "'A" karakterlerini kaldıran fonksiyon
    function removePinarATail() {
        // allCompletedWordStars dizisinde 1. indeks ("PINAR'A")
        const pinarStars = allCompletedWordStars[1];
        if (pinarStars && pinarStars.length >= 2) {
            const starApostrophe = pinarStars[pinarStars.length - 2];
            const starA = pinarStars[pinarStars.length - 1];

            // Karakterleri boşalt ve şeffaflığı sıfırla
            starApostrophe.char = '';
            starApostrophe.alpha = 0;
            starA.char = '';
            starA.alpha = 0;
        }
    }

    // Arka plan yıldızlarını kalplere dönüştüren ve dağıtan fonksiyon
    function transformBackgroundStarsToHeartsAndScatter() {
        const shapes = ['❤︎','♡'];
        let delay = 0;

        // finalDisplayStar veya ScatteredHeart olmayan tüm yıldızları filtrele
        stars.filter(star => !star.isFinalDisplayStar && !star.isScatteredHeart).forEach(star => {
            setTimeout(() => {
                star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Harfi kalbe dönüştür
                // Dönüşen kalpten parçacıklar yay
                for (let i = 0; i < 8; i++) {
                    let ang = Math.random()*Math.PI*2;
                    let spd = 1 + Math.random();
                    particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                }
                star.fixed = false; // Sabitlenmişse hareket etmesine izin ver
                star.isScatteredHeart = true; // Dağılan ve soluklaşan kalp olarak işaretle
                star.alpha = 1; // Tam opak başla
                star.vx = (Math.random() - 0.5) * 3; // Başlangıç dağılma hızı (biraz daha az)
                star.vy = (Math.random() - 0.5) * 3;
                star.size = 20 + Math.random() * 10; // Makul bir boyut ver
            }, delay);
            delay += 50; // Arka plan yıldızlarının dönüşümü arasında kademeli gecikme
        });
    }

    // Son kelime gösterimi animasyonunu başlatan yeni fonksiyon
    function initiateFinalWordDisplayAnimation() {
        finalDisplayAnimationRunning = true;
        finalDisplayAnimationStartTime = Date.now();
        const animationDuration = 10000; // Animasyon süresi: 10 saniye

        const totalWords = allCompletedWordStars.length; // Toplam 4 kelime olmalı
        const lineHeight = 50; // Her kelime satırı için dikey boşluk
        const totalDisplayHeight = totalWords * lineHeight;
        const startY = (canvas.height - totalDisplayHeight) / 2; // İlk kelime için başlangıç Y pozisyonu

        let minPanelX = canvas.width;
        let maxPanelX = 0;
        let minPanelY = canvas.height;
        let maxPanelY = 0;

        ctx.font = '40px Inter, sans-serif'; // Panel boyutunu hesaplarken doğru fontu kullan

        // Her yıldız için hedef pozisyonları hesapla ve panel boyutlarını belirle
        allCompletedWordStars.forEach((wordStars, wordIdx) => {
            // Kelime uzunluğu değişebileceği için her zaman mevcut harflerden kelimeyi yeniden oluştur
            let currentWordString = wordStars.map(s => s.char).join('');
            let wordWidth = ctx.measureText(currentWordString).width;
            let currentXOffset = (canvas.width - wordWidth) / 2; // Kelimeyi ortalamak için başlangıç X

            wordStars.forEach((star, letterIdx) => {
                star.originalX = star.x; // Mevcut pozisyonu animasyon başlangıcı olarak sakla
                star.originalY = star.y;
                star.isFinalDisplayStar = true; // Son gösterimin parçası olarak işaretle

                // Kelime içindeki her harf için hedef X pozisyonunu hesapla
                let accumulatedLetterWidth = 0;
                for(let i = 0; i < letterIdx; i++) {
                    // Sadece görünen karakterlerin genişliğini topla
                    const prevStar = wordStars[i];
                    if (prevStar.char !== '') {
                        accumulatedLetterWidth += ctx.measureText(prevStar.char).width;
                    }
                }
                star.targetX = currentXOffset + accumulatedLetterWidth + ctx.measureText(star.char).width / 2;

                star.targetY = startY + wordIdx * lineHeight + (lineHeight / 2); // Kendi satırında dikey olarak ortala

                // Panel boyutlarını güncelle
                if (star.char !== '') { // Sadece görünen harfleri dikkate al
                    minPanelX = Math.min(minPanelX, star.targetX - ctx.measureText(star.char).width / 2);
                    maxPanelX = Math.max(maxPanelX, star.targetX + ctx.measureText(star.char).width / 2);
                }
                minPanelY = Math.min(minPanelY, star.targetY - lineHeight / 2);
                maxPanelY = Math.max(maxPanelY, star.targetY + lineHeight / 2);
            });
        });

        // Panel boyutları için padding ekle
        const paddingX = 60; // Yatay boşluk
        const paddingY = 40; // Dikey boşluk

        panelRect.x = minPanelX - paddingX / 2;
        panelRect.y = minPanelY - paddingY / 2;
        panelRect.width = (maxPanelX - minPanelX) + paddingX;
        panelRect.height = (maxPanelY - minPanelY) + paddingY;


        // Animasyonun sonunu ve statik gösterime geçişi + dönüşümü zamanla
        setTimeout(() => {
            finalDisplayAnimationRunning = false;
            finalDisplayActive = true; // Kelimeler artık ortada kalıcı olarak sabitlenmiş durumda

            // Kelimeler için dönüşümleri uygula (ÇOK, dinamik) ve PINAR'A
            transformSelectedWordsToHeartsAndScatter();
            removePinarATail();

            // Arka plan yıldızlarının dönüşümünü, kelime dönüşümleri başladıktan kısa bir süre sonra başlat
            setTimeout(() => {
                transformBackgroundStarsToHeartsAndScatter();
            }, 1500); // Kelime dönüşümleri başladıktan sonra 1.5 saniye bekle
        }, animationDuration);
    }

    // Bumerang fırlatma fonksiyonu (kelime tamamlama mantığı)
    function bumerangFırlat(star, force=false) {
      const sx = star.x, sy = star.y;
      const mdx = mouse.mx, mdy = mouse.my;
      const speed = Math.hypot(mdx, mdy);
      const ang = Math.atan2(mdy, mdx);
      const dist = Math.min(200 + speed*15, 800);
      const ox = sx + Math.cos(ang)*dist, oy = sy + Math.sin(ang)*dist;

      let tx, ty;
      if (fixedLetters.length===0) { tx=ox; ty=oy; }
      else { let last = fixedLetters[fixedLetters.length-1]; tx = last.x + 36; ty = last.y; }

      const fd = Math.hypot(ox-sx, oy-sy);
      const bd = Math.hypot(tx-ox, ty-oy);
      const tot = fd + bd;
      const dur = 4500; // Süre 0.5 saniyeden 4.5 saniyeye çıkarıldı (500ms -> 4500ms)
      const ft = fd/tot*dur;
      const bt = dur - ft;
      const mx1 = (sx+ox)/2 + 60, my1 = (sy+oy)/2 - 60;
      const mx2 = (ox+tx)/2 + 60, my2 = (oy+ty)/2 - 60;
      const start = Date.now(), ia = star.angle;

      function step() {
        let e = Date.now() - start;
        if (e > dur) e = dur;
        const t = e/dur;
        star.angle = ia*(1-t);

        let cx, cy;
        if (e <= ft) {
          const p = e/ft;
          const a = (1-p)**2, b = 2*(1-p)*p, c = p**2;
          cx = a*sx + b*mx1 + c*ox;
          cy = a*sy + b*my1 + c*oy;
        } else {
          const p = (e-ft)/bt;
          const a = (1-p)**2, b = 2*(1-p)*p, c = p**2;
          cx = a*ox + b*mx2 + c*tx;
          cy = a*oy + b*my2 + c*ty;
        }
        star.x = cx; star.y = cy;
        star.size = star.baseSize + (31-star.baseSize)*t;

        if (e<dur) {
          requestAnimationFrame(step);
        } else {
          star.x = tx; star.y = ty; star.size = 31; star.fixed = true; star.wordIndex = wordIndex;
          const exp = currentWord[currentIndex] || '';

          if (star.char===exp || force || (currentWord==='ÇOK' && exp==='K' && star.char==='O')) {
            fixedLetters.push(star);
            if (!force && star.char===exp) currentIndex++;
          }

          // Kelime tamamlama kontrolü
          if (currentIndex >= currentWord.length) {
            if (currentWord==='ÇOK') {
              allCompletedWordStars.push([...fixedLetters]); // 'ÇOK' kelimesinin harflerini sakla
              dynamicMode = true;
              fixedLetters = []; // Dinamik kelime için 'ÇOK' harflerini temizle
              currentIndex=0;
              secondPhase=false;
            } else if (wordIndex < wordList.length-1) { // Önceden tanımlanmış kelimeler (ALTAY, PINAR'A)
              allCompletedWordStars.push([...fixedLetters]); // Tamamlanmış kelimeyi sakla
              wordIndex++; // Bir sonraki önceden tanımlanmış kelimeye geç
              currentWord=wordList[wordIndex];
              fixedLetters=[]; // Yeni kelime için harfleri temizle
              currentIndex=0;
            } else { // Burası *dinamik kelimenin* tamamlandığı blok
              allCompletedWordStars.push([...fixedLetters]); // Dinamik kelimenin harflerini sakla
              // Kelime oluşturmaya özgü oyun değişkenlerini sıfırla
              fixedLetters = [];
              currentIndex = 0;
              // Şimdi son animasyon ve gösterimi başlat
              initiateFinalWordDisplayAnimation();
            }
          }
        }
      }
      step();
    }

    // Oyunu sıfırlama fonksiyonu
    function reset() {
      stars=[];
      for(let i=0;i<120;i++) stars.push(new Star());
      particles=[];
      fixedLetters=[];
      wordIndex=0; currentWord=wordList[0]; currentIndex=0;
      dynamicMode=false; secondPhase=false;
      // Yeni global değişkenleri sıfırla
      allCompletedWordStars = [];
      finalDisplayAnimationRunning = false;
      finalDisplayAnimationStartTime = 0;
      finalDisplayActive = false;
      panelRect = { x: 0, y: 0, width: 0, height: 0 }; // Paneli sıfırla
    }
    reset(); // Yüklemede oyunu başlat

    // Olay Dinleyicileri
    window.addEventListener('mousemove', e => {
      mouse.px = mouse.x; mouse.py = mouse.y;
      mouse.x = e.clientX; mouse.y = e.clientY;
      lastMove = Date.now();
      mouse.mx = mouse.x - mouse.px;
      mouse.my = mouse.y - mouse.py;

      const dx = mouse.px - mouse.x;
      const dy = mouse.py - mouse.y;
      const m = Math.hypot(dx, dy);
      if (m>1) for(let i=0;i<3;i++) particles.push(new Particle(
        mouse.x, mouse.y,
        dx*0.02 + (Math.random()-0.5)*0.5,
        dy*0.02 + (Math.random()-0.5)*1
      ));
    });

    window.addEventListener('mousedown', ()=>{
      for(let s of stars) {
        const dx = s.x - mouse.x;
        const dy = s.y - mouse.y;
        if (Math.hypot(dx, dy) < 20) { held = s; break; }
      }
    });

    window.addEventListener('mouseup', ()=>{
      if (!held) return;

      // Kelimeler son statik gösterimde veya animasyon sırasında ise etkileşimi engelle
      if (finalDisplayActive || finalDisplayAnimationRunning) {
          held = null;
          return;
      }

      const c = held.char;

      if (dynamicMode) {
        if (!secondPhase) {
          options = wordGroups[c] || [];
          if (options.length > 0) {
            bumerangFırlat(held, true);
            if (options.length > 1) {
              secondPhase = true;
            } else {
              currentWord = options[0];
              dynamicMode = false;
              currentIndex = 1;
            }
          } else {
            held.vx = mouse.mx * 0.3; held.vy = mouse.my * 0.3;
          }
          held = null; return;
        } else {
          const match = options.find(w => w[1] === c);
          if (match) {
            bumerangFırlat(held, true);
            currentWord = match;
            secondPhase = false;
            dynamicMode = false;
            currentIndex = 2;
          } else {
            held.vx = mouse.mx * 0.3; held.vy = mouse.my * 0.3;
          }
          held = null; return;
        }
      }

      const exp = currentWord[currentIndex] || '';
      if (c === exp) {
        bumerangFırlat(held);
      } else if (currentWord === 'ÇOK' && exp === 'K' && c === 'O') {
          bumerangFırlat(held);
      }
      else {
          held.vx = mouse.mx * 0.3; held.vy = mouse.my * 0.3;
      }
      held = null;
    });

    window.addEventListener('keydown', e => {
      if (e.code==='Space') { reset(); return; }
      const k = e.key.toUpperCase();
      if (letters.includes(k) && !activeKeys.has(k)) {
        keyTimers[k] = Date.now(); activeKeys.add(k);
        stars.push(new Star(k));
      }
    });

    window.addEventListener('keyup', e => {
      const k = e.key.toUpperCase();
      if (activeKeys.has(k)) { delete keyTimers[k]; activeKeys.delete(k); }
    });

    window.addEventListener('keydown', e => {
      if (e.code==='Enter') {
        const shapes=['❤︎','♡'];
        for(let i=0;i<15;i++){
          const x=Math.random()*canvas.width;
          const y=Math.random()*canvas.height;
          const heart=new Star(shapes[Math.floor(Math.random()*shapes.length)]);
          heart.x=x; heart.y=y; heart.fixed=true;
          stars.push(heart);
          setTimeout(()=>{
            const idx=stars.indexOf(heart);
            if(idx!==-1) stars.splice(idx,1);
          },2000);
        }
      }
    });

    // Ana animasyon döngüsü
    function animate() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // Tüm canvası temizle

      // Kelimeler ortaya geldiyse veya animasyon sürüyorsa paneli çiz
      if (finalDisplayAnimationRunning || finalDisplayActive) {
          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Yarı saydam siyah
          // ctx.shadowColor = 'rgba(255, 255, 255, 0.3)'; // GLOW KALDIRILDI
          // ctx.shadowBlur = 15; // GLOW KALDIRILDI
          ctx.roundRect(panelRect.x, panelRect.y, panelRect.width, panelRect.height, panelRadius);
          ctx.fill();
          ctx.restore(); // Context'i eski haline getir (gölgeyi diğer çizimlerden kaldır)
      }

      // Parçacıklar her zaman çizilir
      particles.forEach(p=>{ p.update(); p.draw(); });
      particles = particles.filter(p=>p.life>0);

      // Yıldızlar (harfler) her zaman çizilir
      stars.forEach(s=>{ s.update(); s.draw(); }); // Star.update ve Star.draw artık isScatteredHeart ve isFinalDisplayStar mantığını işler

      requestAnimationFrame(animate); // Sonraki animasyon karesini iste
    }
    animate(); // Animasyon döngüsünü başlat
  </script>
</body>
</html>
