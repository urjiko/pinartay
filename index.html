<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harfli Uzay Oyunu</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; cursor: none; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="space"></canvas>
  <script>
    // Canvas setup
    const canvas = document.getElementById('space');
    const ctx = canvas.getContext('2d');
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // Function added to CanvasRenderingContext2D prototype for drawing rounded rectangles
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2*r) r = w/2;
      if (h < 2*r) r = h/2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.arcTo(x + w, y, x + w, y + r, r);
      this.lineTo(x + w, y + h - r);
      this.arcTo(x + w, y + h, x + w - r, y + h, r);
      this.lineTo(x + r, y + h);
      this.arcTo(x, y + h, x, y + h - r, r);
      this.lineTo(x, y + r);
      this.arcTo(x, y, x + r, y, r);
      this.closePath();
    };

    // Global game state variables
    const letters = "ABCDEFGHIJKLMNOPRSTUVYZ'ÇÖÜİĞŞ".split(''); // Letters to be used
    const FIXED_LETTER_SIZE = 31; // Constant for the fixed size of letters in words

    let particles = []; // Particles for visual effects when mouse moves
    let stars = [];     // Letters floating in space (stars)
    let fixedLetters = []; // Letters placed to form a word
    let held = null;    // Current letter/star dragged by the mouse
    let mouse = { x:0, y:0, px:0, py:0, mx:0, my:0 }; // Mouse position and movement
    let lastMove = Date.now(); // Timestamp of the last mouse movement
    let keyTimers = {}; // To track how long a key is pressed
    let activeKeys = new Set(); // Currently pressed keys

    // New global variables for final display and animation of words
    let allCompletedWordStars = [];      // Stores arrays of Star objects for each completed word
    let finalDisplayAnimationRunning = false; // true during the 10-second gathering animation
    let finalDisplayAnimationStartTime = 0;   // Timestamp when the final display animation started
    let finalDisplayActive = false;       // true when words are permanently fixed in the center

    // New global variables for the background panel
    let panelRect = { x: 0, y: 0, width: 0, height: 0 };
    let panelRadius = 20; // Radius for rounded corners of the panel


    // Word lists for game progression
    const wordList = ["ALTAY","PINAR'A","ÇOK"]; // Predefined words
    const wordGroups = { // Options for dynamic words based on the first selected letter
      A:["AŞIK","AZIYOR"], Ö:["ÖLÜYOR"], B:["BİTİYOR"], E:["ERİYOR"],
      Y:["YÜKSELİYOR"], T:["TAPIYOR"], H:["HAYRAN"],
      C:["COŞUYOR"], Ç:["ÇABALADI"], D:["DELİRİYOR"], F:["FETİŞ"], G:["GÜLÜYOR"],
      I:["ISLAK"], İ:["İSTEKLİ"], K:["KALP"], L:["LOVE"], M:["MÜPTELA"],
      N:["NİYETLİ"], O:["OKŞUYOR"], P:["PSPSPS"], R:["RAZI"],
      S:["SEVİŞİYOR"], Ş:["ŞEHVETLİ"], U:["UYAR"], Ü:["ÜLFET"],
      V:["VAKUM"], Z:["ZİMMETLİ"]
    };
    let wordIndex = 0;      // Current index in the predefined word list
    let currentWord = wordList[wordIndex]; // Word currently being formed
    let currentIndex = 0;   // Current letter index within currentWord
    let dynamicMode = false; // true when selecting the first letter of a dynamic word
    let options = [];        // Possible dynamic words after first letter selection
    let secondPhase = false; // true when selecting the second letter of a dynamic word (if multiple options)

    // Particle class for visual effects
    class Particle {
      constructor(x,y,vx,vy) {
        this.x=x; this.y=y; // Position
        this.vx=vx; this.vy=vy; // Velocity
        this.life=1; // Life cycle (decreases over time)
      }
      update() {
        this.x += this.vx; this.y += this.vy; // Move particle
        this.life -= 0.02; // Decrease life
      }
      draw() {
        if (this.life <= 0.1) return; // Don't draw if almost gone
        ctx.globalAlpha = this.life; // Set transparency based on life
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2); // Draw a small white circle
        ctx.fill();
        ctx.globalAlpha = 1; // Reset transparency
      }
    }

    // Star (Letter) class
    class Star {
      constructor(c) {
        this.char = c || letters[Math.floor(Math.random()*letters.length)]; // Assign a random letter or specified letter
        this.x = Math.random()*canvas.width; // Random starting X position
        this.y = Math.random()*canvas.height; // Random starting Y position
        this.vx = (Math.random()-0.5)*0.3; // Random starting X velocity
        this.vy = (Math.random()-0.5)*0.3; // Random starting Y velocity
        this.baseSize = 14 + Math.random()*8; // Base font size
        this.size = this.baseSize; // Current font size
        this.alpha = 0.3 + Math.random()*0.7; // Transparency
        this.angle = Math.random()*Math.PI*2; // Starting rotation angle
        this.spin = (Math.random()-0.5)*0.01; // Rotation speed
        this.fixed = false; // true if letter is part of a completed word
        this.wordIndex = wordIndex; // Word index this star belongs to (useful for heart transformation)

        // New properties for final display animation and scattering
        this.originalX = this.x;
        this.originalY = this.y;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isFinalDisplayStar = false; // Flag to mark stars that will be part of the final centered display
        this.isScatteredHeart = false;   // Flag to mark as a scattered heart

        // New properties: Target positions for fixed letters (for smooth movement)
        this.targetFixedX = null;
        this.targetFixedY = null;
      }
      update() {
        // If this star is a scattered heart, apply unique update logic
        if (this.isScatteredHeart) {
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98; // Dampening
            this.vy *= 0.98; // Dampening
            this.alpha -= 0.003; // Slowly fade out
            if (this.alpha <= 0) {
                // Remove star from global stars array when completely faded
                const index = stars.indexOf(this);
                if (index > -1) {
                    stars.splice(index, 1);
                }
            }
            return; // Skip other update logic
        }

        // If this star is part of the final, fixed display (ALTAY, PINAR or disappearing 'A)
        if (this.isFinalDisplayStar) {
            if (finalDisplayAnimationRunning) {
                let elapsed = Date.now() - finalDisplayAnimationStartTime;
                let t = Math.min(1, elapsed / 10000); // Normalize time to 0-1 range (over 10 seconds)
                this.x = this.originalX + (this.targetX - this.originalX) * t; // Move towards target
                this.y = this.originalY + (this.targetY - this.originalY) * t;
                this.size = FIXED_LETTER_SIZE; // Maintain fixed size during animation
                this.alpha = 1; // Full opacity during animation
            } else if (finalDisplayActive) {
                // Permanently fixed in center after animation
                this.x = this.targetX;
                this.y = this.targetY;
                this.size = FIXED_LETTER_SIZE; // Maintain final size
                // Set alpha to 0 if character is empty string, otherwise 1
                this.alpha = (this.char === '') ? 0 : 1;
            }
            this.vx = 0; this.vy = 0; // Stop any velocity
            return; // Skip normal star movement
        }

        // If the letter is fixed (part of a word)
        if (this.fixed) {
            // Smooth movement towards target position
            if (this.targetFixedX !== null && Math.abs(this.x - this.targetFixedX) > 0.5) {
                this.x += (this.targetFixedX - this.x) * 0.15; // Smooth transition speed
            } else if (this.targetFixedX !== null) {
                this.x = this.targetFixedX; // Fix if close enough
                this.targetFixedX = null; // Target reached, reset
            }

            if (this.targetFixedY !== null && Math.abs(this.y - this.targetFixedY) > 0.5) {
                this.y += (this.targetFixedY - this.y) * 0.15; // Smooth transition speed
            } else if (this.targetFixedY !== null) {
                this.y = this.targetFixedY; // Fix if close enough
                this.targetFixedY = null; // Target reached, reset
            }
            return; // Fixed letters don't use other movement logic
        }

        // Current normal star update logic (only for stars that are not finalDisplayStar or ScatteredHeart)
        if (held === this) { // If this star is held by the mouse
          this.x = mouse.x; this.y = mouse.y; // Follow mouse
          this.vx = this.vy = 0; // Stop movement
          return;
        }
        this.x += this.vx; // Apply velocity
        this.y += this.vy;
        // Bounce off canvas edges
        if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
        if (this.x > canvas.width) { this.x = canvas.width; this.vx *= -0.5; }
        if (this.y < 0) { this.y = 0; this.vy *= -0.5; }
        if (this.y > canvas.height) { this.y = canvas.height; this.vy *= -0.5; }
        if (!this.fixed) this.angle += this.spin; // Rotate if not fixed

        // Attraction effect towards mouse if mouse moved recently
        const dt = Date.now() - lastMove;
        if (dt < 2000) { // If mouse moved within the last 2 seconds
          let dx = mouse.x - this.x;
          let dy = mouse.y - this.y;
          let d = Math.hypot(dx, dy); // Distance to mouse
          if (d < 150 && held !== this) { // If within attraction radius and not held
            let s = (150 - d)/150; // Attraction strength
            this.x += dx*0.05*s; // Move towards mouse
            this.y += dy*0.05*s;
            this.size = this.baseSize*(1-0.4*s); // Shrink slightly
          }
        } else {
          this.size += (this.baseSize - this.size)*0.1; // Return to base size if no mouse interaction
        }

        // Acceleration effect when a key is pressed (attracts same letters towards mouse)
        for (let k of activeKeys) {
          if (k === this.char) {
            let dur = (Date.now() - keyTimers[k]) / 1000; // Duration key has been pressed
            let boost = Math.min(dur, 3); // Maximum boost
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            this.x += dx*0.01*boost; // Move towards mouse
            this.y += dy*0.01*boost;
          }
        }
      }
      draw() {
        ctx.save();

        if (this.isScatteredHeart) {
            if (this.alpha <= 0) { // Don't draw if completely faded
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = 'white'; // Hearts are white
            ctx.font = this.size + 'px Inter, sans-serif'; // Use current size
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        if (this.isFinalDisplayStar) {
            if (this.char === '' && this.alpha === 0) { // Don't draw disappearing parts
                ctx.restore();
                return;
            }
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.alpha; // Use current alpha value
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'white'; ctx.shadowBlur = 8;
            ctx.font = this.size + 'px Inter, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, 0, 0);
            ctx.restore();
            ctx.globalAlpha = 1;
            return;
        }

        // Current normal star drawing logic
        let lev = this.fixed ? Math.sin(Date.now()/500 + this.x)*1.5 : 0; // Slight ripple effect for fixed letters
        ctx.translate(this.x, this.y + lev); // this.x, this.y set by update function
        if (!this.fixed) ctx.rotate(this.angle); // Rotate if not fixed
        if (this.fixed) { // Style for fixed letters (part of a word)
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.3)'; // Semi-transparent black background
          ctx.roundRect(-this.size*0.45, -this.size*0.45, this.size*0.9, this.size*0.9, this.size*0.25);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = 'white'; // Beyaz harf
          ctx.shadowColor = 'white'; ctx.shadowBlur = 3; // Slight glow
        } else { // Style for freely floating letters
          ctx.globalAlpha = this.alpha; // Apply transparency
          ctx.fillStyle = 'white'; ctx.shadowColor = 'white'; ctx.shadowBlur = 4; // White letter with stronger glow
        }
        ctx.font = (held===this ? this.size*2 : this.size) + 'px Inter, sans-serif'; // Larger if held
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.char, 0, 0); // Draw letter
        ctx.restore();
        ctx.globalAlpha = 1; // Reset transparency
      }
    }

    // Function to transform selected words into hearts and scatter them (ÇOK and Dynamic Word)
    function transformSelectedWordsToHeartsAndScatter() {
        const shapes = ['❤︎','♡']; // Heart shapes
        let delay = 0;

        // 2nd index ('ÇOK') and 3rd index (dynamic word) in allCompletedWordStars array
        const wordsToTransform = [allCompletedWordStars[2], allCompletedWordStars[3]];

        wordsToTransform.forEach(wordStars => {
            if (!wordStars) return; // Safety check if word doesn't exist

            wordStars.forEach(star => {
                setTimeout(() => {
                    star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Transform letter to heart
                    // Emit particles from the transformed heart
                    for (let i = 0; i < 8; i++) {
                        let ang = Math.random()*Math.PI*2;
                        let spd = 1 + Math.random();
                        particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                    }
                    star.isFinalDisplayStar = false; // No longer part of the fixed central display
                    star.fixed = false; // Allow it to move
                    star.isScatteredHeart = true; // Mark as scattered and fading heart
                    star.vx = (Math.random() - 0.5) * 5; // Initial scatter velocity
                    star.vy = (Math.random() - 0.5) * 5;
                    star.alpha = 1; // Start with full opacity
                    star.size = 40; // Maintain large size for hearts
                }, delay);
                delay += 100; // Small delay between letters
            });
            delay += 500; // Larger delay between words
        });
    }

    // Function to remove "'A" characters at the end of "PINAR'A" word
    function removePinarATail() {
        // 1st index ("PINAR'A") in allCompletedWordStars array
        const pinarStars = allCompletedWordStars[1];
        if (pinarStars && pinarStars.length >= 2) {
            const starApostrophe = pinarStars[pinarStars.length - 2];
            const starA = pinarStars[pinarStars.length - 1];

            // Empty characters and set alpha to 0
            starApostrophe.char = '';
            starApostrophe.alpha = 0;
            starA.char = '';
            starA.alpha = 0;
        }
    }

    // Function to transform background stars into hearts and scatter them
    function transformBackgroundStarsToHeartsAndScatter() {
        const shapes = ['❤︎','♡'];
        let delay = 0;

        // Filter all stars that are not finalDisplayStar or ScatteredHeart
        stars.filter(star => !star.isFinalDisplayStar && !star.isScatteredHeart).forEach(star => {
            setTimeout(() => {
                star.char = shapes[Math.floor(Math.random()*shapes.length)]; // Transform letter to heart
                // Emit particles from the transformed heart
                for (let i = 0; i < 8; i++) {
                    let ang = Math.random()*Math.PI*2;
                    let spd = 1 + Math.random();
                    particles.push(new Particle(star.x, star.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                }
                star.fixed = false; // Allow movement if fixed
                star.isScatteredHeart = true; // Mark as scattered and fading heart
                star.alpha = 1; // Start with full opacity
                star.vx = (Math.random() - 0.5) * 3; // Initial scatter velocity (slightly less)
                star.vy = (Math.random() - 0.5) * 3;
                star.size = 20 + Math.random() * 10; // Give a reasonable size
            }, delay);
            delay += 50; // Gradual delay between background star transformations
        });
    }

    // New function to initiate the final word display animation
    function initiateFinalWordDisplayAnimation() {
        finalDisplayAnimationRunning = true;
        finalDisplayAnimationStartTime = Date.now();
        const animationDuration = 10000; // Animation duration: 10 seconds

        const totalWords = allCompletedWordStars.length; // Should be 4 words in total
        const lineHeight = 50; // Vertical spacing for each word line
        const totalDisplayHeight = totalWords * lineHeight;
        const startY = (canvas.height - totalDisplayHeight) / 2; // Starting Y position for the first word

        let minPanelX = canvas.width;
        let maxPanelX = 0;
        let minPanelY = canvas.height;
        let maxPanelY = 0;

        ctx.font = `${FIXED_LETTER_SIZE}px Inter, sans-serif`; // Use correct font for panel size calculation

        // Calculate target positions for each star and determine panel dimensions
        allCompletedWordStars.forEach((wordStars, wordIdx) => {
            // Reconstruct word from current letters as length might change
            let currentWordString = wordStars.map(s => s.char).join('');
            let wordWidth = ctx.measureText(currentWordString).width;

            const horizontalPadding = 30; // Minimum padding from screen edge

            let effectiveWordStartX = (canvas.width - wordWidth) / 2; // Attempt to center

            // If word overflows to the right, shift left
            if (effectiveWordStartX + wordWidth > canvas.width - horizontalPadding) {
                effectiveWordStartX = canvas.width - wordWidth - horizontalPadding;
            }

            // If word overflows to the left (even after previous adjustment), shift right (maintain minimum padding)
            effectiveWordStartX = Math.max(effectiveWordStartX, horizontalPadding);


            wordStars.forEach((star, letterIdx) => {
                star.originalX = star.x; // Store current position as animation start
                star.originalY = star.y;
                star.isFinalDisplayStar = true; // Mark as part of final display

                // Calculate target X position for each letter within the word
                let accumulatedLetterWidth = 0;
                for(let i = 0; i < letterIdx; i++) {
                    // Sum width of only visible characters
                    const prevStar = wordStars[i];
                    if (prevStar.char !== '') {
                        accumulatedLetterWidth += ctx.measureText(prevStar.char).width;
                    }
                }
                star.targetX = effectiveWordStartX + accumulatedLetterWidth + ctx.measureText(star.char).width / 2;

                star.targetY = startY + wordIdx * lineHeight + (lineHeight / 2); // Vertically center on its line

                // Update panel dimensions
                if (star.char !== '') { // Only consider visible letters
                    minPanelX = Math.min(minPanelX, star.targetX - ctx.measureText(star.char).width / 2);
                    maxPanelX = Math.max(maxPanelX, star.targetX + ctx.measureText(star.char).width / 2);
                }
                minPanelY = Math.min(minPanelY, star.targetY - lineHeight / 2);
                maxPanelY = Math.max(maxPanelY, star.targetY + lineHeight / 2);
            });
        });

        // Add padding for panel dimensions
        const paddingX = 60; // Horizontal padding
        const paddingY = 40; // Vertical padding

        panelRect.x = minPanelX - paddingX / 2;
        panelRect.y = minPanelY - paddingY / 2;
        panelRect.width = (maxPanelX - minPanelX) + paddingX;
        panelRect.height = (maxPanelY - minPanelY) + paddingY;

        // Ensure panelRect stays within canvas bounds
        panelRect.x = Math.max(0, panelRect.x);
        panelRect.y = Math.max(0, panelRect.y);
        if (panelRect.x + panelRect.width > canvas.width) {
            panelRect.width = canvas.width - panelRect.x;
        }
        if (panelRect.y + panelRect.height > canvas.height) {
            panelRect.height = canvas.height - panelRect.y;
        }

        // Schedule end of animation and transition to static display + transformation
        setTimeout(() => {
            finalDisplayAnimationRunning = false;
            finalDisplayActive = true; // Words are now permanently fixed in the center

            // Apply transformations for words (ÇOK, dynamic) and PINAR'A
            transformSelectedWordsToHeartsAndScatter();
            removePinarATail();

            // Start background stars transformation shortly after word transformations begin
            setTimeout(() => {
                transformBackgroundStarsToHeartsAndScatter();
            }, 1500); // Wait 1.5 seconds after word transformations start
        }, animationDuration);
    }

    // Boomerang throw function (only animates and physically fixes the star)
    function bumerangFırlat(star, onCompleteCallback) {
      const sx = star.x, sy = star.y;
      const mdx = mouse.mx, mdy = mouse.my;
      const speed = Math.hypot(mdx, mdy);
      const ang = Math.atan2(mdy, mdx);
      const dist = Math.min(200 + speed*15, 800);
      const ox = sx + Math.cos(ang)*dist, oy = sy + Math.sin(ang)*dist;

      let tx, ty;
      if (fixedLetters.length === 0) { tx = ox; ty = oy; }
      else { let last = fixedLetters[fixedLetters.length - 1]; tx = last.x + 36; ty = last.y; }

      const fd = Math.hypot(ox - sx, oy - sy);
      const bd = Math.hypot(tx - ox, ty - oy);
      const tot = fd + bd;
      const dur = 4500;
      const ft = fd / tot * dur;
      const bt = dur - ft;
      const mx1 = (sx + ox) / 2 + 60, my1 = (sy + oy) / 2 - 60;
      const mx2 = (ox + tx) / 2 + 60, my2 = (oy + ty) / 2 - 60;
      const start = Date.now(), ia = star.angle;

      function step() {
        let e = Date.now() - start;
        if (e > dur) e = dur;
        const t = e / dur;
        star.angle = ia * (1 - t);

        let cx, cy;
        if (e <= ft) {
          const p = e / ft;
          const a = (1 - p) ** 2, b = 2 * (1 - p) * p, c = p ** 2;
          cx = a * sx + b * mx1 + c * ox;
          cy = a * sy + b * my1 + c * oy;
        } else {
          const p = (e - ft) / bt;
          const a = (1 - p) ** 2, b = 2 * (1 - p) * p, c = p ** 2;
          cx = a * ox + b * mx2 + c * tx;
          cy = a * oy + b * my2 + c * ty;
        }
        star.x = cx; star.y = cy;
        star.size = star.baseSize + (FIXED_LETTER_SIZE - star.baseSize) * t;

        if (e < dur) {
          requestAnimationFrame(step);
        } else {
          star.x = tx; star.y = ty;
          star.size = FIXED_LETTER_SIZE;
          star.fixed = true;
          star.wordIndex = wordIndex;

          if (onCompleteCallback) {
            onCompleteCallback(star);
          }
        }
      }
      step();
    }

    // Recalculates and applies target positions for all fixed letters
    function recalculateFixedLetterPositions() {
      const letterPadding = 36;
      ctx.font = `${FIXED_LETTER_SIZE}px Inter, sans-serif`; // Set correct font for text measurements

      let totalCurrentWordWidth = 0;
      for (let i = 0; i < fixedLetters.length; i++) {
          totalCurrentWordWidth += ctx.measureText(fixedLetters[i].char).width;
          if (i < fixedLetters.length - 1) {
              totalCurrentWordWidth += letterPadding;
          }
      }

      const minScreenPadding = 30; // Minimum horizontal padding from screen edges
      const verticalWordSpacing = 60; // Spacing between different completed words (vertical)
      const fixedLetterHeight = FIXED_LETTER_SIZE; // Approx height of fixed letter for vertical spacing

      let currentWordBlockY;
      if (fixedLetters.length === 1) {
          // If this is the first letter, use its current Y (which would be its landing spot)
          currentWordBlockY = fixedLetters[0].y;
      } else {
          // For subsequent letters, derive word's Y from the first fixed letter's target Y or current Y
          currentWordBlockY = fixedLetters[0].targetFixedY !== null ? fixedLetters[0].targetFixedY : fixedLetters[0].y;
      }

      for (const completedWordStars of allCompletedWordStars) {
          if (completedWordStars.length > 0) {
              const completedWordFirstStar = completedWordStars[0];
              const completedWordCenterY = completedWordFirstStar.targetFixedY !== null ? completedWordFirstStar.targetFixedY : completedWordFirstStar.y;

              const completedWordTop = completedWordCenterY - (fixedLetterHeight / 2);
              const completedWordBottom = completedWordCenterY + (fixedLetterHeight / 2);

              const currentWordTop = currentWordBlockY - (fixedLetterHeight / 2);
              const currentWordBottom = currentWordBlockY + (fixedLetterHeight / 2);

              if (currentWordTop < completedWordBottom && currentWordBottom > completedWordTop) {
                  currentWordBlockY = completedWordBottom + (fixedLetterHeight / 2) + verticalWordSpacing;
              }
          }
      }

      currentWordBlockY = Math.max(minScreenPadding + fixedLetterHeight / 2, currentWordBlockY);
      currentWordBlockY = Math.min(canvas.height - minScreenPadding - fixedLetterHeight / 2, currentWordBlockY);

      let currentWordBlockStartX;
      if (fixedLetters.length === 1) {
          currentWordBlockStartX = fixedLetters[0].x - (ctx.measureText(fixedLetters[0].char).width / 2);
      } else {
          currentWordBlockStartX = fixedLetters[0].targetFixedX !== null ? fixedLetters[0].targetFixedX - (ctx.measureText(fixedLetters[0].char).width / 2) : fixedLetters[0].x - (ctx.measureText(fixedLetters[0].char).width / 2);
      }

      if (currentWordBlockStartX + totalCurrentWordWidth > canvas.width - minScreenPadding) {
          currentWordBlockStartX = canvas.width - totalCurrentWordWidth - minScreenPadding;
      }
      currentWordBlockStartX = Math.max(minScreenPadding, currentWordBlockStartX);

      let currentPlacementWidth = 0;
      for (let i = 0; i < fixedLetters.length; i++) {
          const fLetter = fixedLetters[i];
          const charWidth = ctx.measureText(fLetter.char).width;
          fLetter.targetFixedX = currentWordBlockStartX + currentPlacementWidth + (charWidth / 2);
          fLetter.targetFixedY = currentWordBlockY;
          currentPlacementWidth += charWidth;
          if (i < fixedLetters.length - 1) {
              currentPlacementWidth += letterPadding;
          }
      }
    }

    // Checks if the current word is completed and moves to the next stage
    function checkWordCompletion() {
      let wordCompleted = false;

      if (currentWord === 'ÇOK') {
          // 'ÇOK' is complete when 'K' is placed, which means currentIndex becomes 2.
          if (currentIndex === 2) {
              wordCompleted = true;
          }
      } else if (currentWord && !dynamicMode) { // For ALTAY, PINAR'A, and the chosen dynamic word (not in selection phase)
          if (currentIndex >= currentWord.length) {
              wordCompleted = true;
          }
      }

      if (wordCompleted) {
          allCompletedWordStars.push([...fixedLetters]);
          fixedLetters = []; // Clear letters for next word

          if (currentWord === 'ÇOK') { // Transition from 'ÇOK' to dynamic word selection
              dynamicMode = true;
              currentWord = ''; // Clear currentWord to signal dynamic selection phase
              currentIndex = 0; // Reset for first char selection of dynamic word
              secondPhase = false;
          } else if (wordIndex < wordList.length - 1) { // Move to next predefined word
              wordIndex++;
              currentWord = wordList[wordIndex];
              currentIndex = 0;
          } else { // All words (predefined + dynamic) are done
              initiateFinalWordDisplayAnimation();
          }
      }
    }

    // Function to reset the game
    function reset() {
      stars=[];
      for(let i=0;i<120;i++) stars.push(new Star());
      particles=[];
      fixedLetters=[];
      wordIndex=0; currentWord=wordList[0]; currentIndex=0;
      dynamicMode=false; secondPhase=false;
      // Reset new global variables
      allCompletedWordStars = [];
      finalDisplayAnimationRunning = false;
      finalDisplayAnimationStartTime = 0;
      finalDisplayActive = false;
      panelRect = { x: 0, y: 0, width: 0, height: 0 }; // Reset panel
    }
    reset(); // Start game on load

    // Helper function to update mouse/touch event coordinates
    function updateMouseCoordinates(clientX, clientY) {
      mouse.px = mouse.x;
      mouse.py = mouse.y;
      mouse.x = clientX;
      mouse.y = clientY;
      lastMove = Date.now();
      mouse.mx = mouse.x - mouse.px;
      mouse.my = mouse.y - mouse.py;

      const dx = mouse.px - mouse.x;
      const dy = mouse.py - mouse.y;
      const m = Math.hypot(dx, dy);
      if (m > 1) {
        for (let i = 0; i < 3; i++) {
          particles.push(new Particle(
            mouse.x, mouse.y,
            dx * 0.02 + (Math.random() - 0.5) * 0.5,
            dy * 0.02 + (Math.random() - 0.5) * 1
          ));
        }
      }
    }

    // Mouse Event Listeners
    window.addEventListener('mousemove', e => {
      updateMouseCoordinates(e.clientX, e.clientY);
    });

    window.addEventListener('mousedown', ()=>{
      for(let s of stars) {
        const dx = s.x - mouse.x;
        const dy = s.y - mouse.y;
        // Only allow holding non-fixed stars
        if (Math.hypot(dx, dy) < 20 && !s.fixed) {
          held = s;
          break;
        }
      }
    });

    window.addEventListener('mouseup', ()=>{
      if (!held) return;

      // Prevent interaction if words are in final static display or during animation
      if (finalDisplayActive || finalDisplayAnimationRunning) {
          held = null;
          return;
      }

      const charThrown = held.char;
      const thrownStar = held;
      
      if (dynamicMode) {
        if (!secondPhase) { // Selecting first letter of dynamic word
          options = wordGroups[charThrown] || [];
          if (options.length > 0) {
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star); // Add to fixedLetters
                if (options.length > 1) {
                    secondPhase = true;
                    currentIndex = 1; // First char of dynamic word picked
                } else {
                    currentWord = options[0];
                    dynamicMode = false;
                    currentIndex = 1; // First char of actual dynamic word (e.g., AŞIK)
                }
                recalculateFixedLetterPositions(); // Recalculate positions after adding
                checkWordCompletion(); // Check completion after adding
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3; // Release if not valid
            thrownStar.fixed = false; // Ensure it's not fixed
          }
        } else { // secondPhase
          const match = options.find(w => w[1] === charThrown);
          if (match) {
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star); // Add to fixedLetters
                currentWord = match;
                secondPhase = false;
                dynamicMode = false;
                currentIndex = 2; // Second char of actual dynamic word
                recalculateFixedLetterPositions(); // Recalculate positions after adding
                checkWordCompletion(); // Check completion after adding
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3; // Release if not valid
            thrownStar.fixed = false; // Ensure it's not fixed
          }
        }
      } else { // Predefined words (ALTAY, PINAR'A, ÇOK)
        let shouldAccept = false;
        let shouldIncrement = false;

        const expectedCharForCurrentIndex = currentWord[currentIndex];

        if (currentWord === 'ÇOK') {
            if (currentIndex === 0 && charThrown === 'Ç') {
                shouldAccept = true;
                shouldIncrement = true;
            } else if (currentIndex === 1 && charThrown === 'O') {
                shouldAccept = true;
                shouldIncrement = false; // Don't increment index for multiple 'O's
            } else if (currentIndex === 1 && charThrown === 'K') {
                shouldAccept = true;
                shouldIncrement = true; // Increment index for 'K'
            }
        } else { // For ALTAY, PINAR'A
            if (charThrown === expectedCharForCurrentIndex) {
                shouldAccept = true;
                shouldIncrement = true;
            }
        }

        if (shouldAccept) {
            bumerangFırlat(thrownStar, (star) => { // Callback after animation
                fixedLetters.push(star);
                if (shouldIncrement) {
                    currentIndex++;
                }
                recalculateFixedLetterPositions(); // Recalculate positions after adding
                checkWordCompletion(); // Check completion after adding
            });
        } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
        }
      }
      held = null; // Ensure held is always null after mouseup
    });

    // Dokunmatik Olay Dinleyicileri (Eklenenler)
    window.addEventListener('touchstart', e => {
      e.preventDefault(); // Varsayılan dokunma davranışını (kaydırma, yakınlaştırma) engelle
      if (e.touches.length > 0) {
        updateMouseCoordinates(e.touches[0].clientX, e.touches[0].clientY);
        for(let s of stars) {
          const dx = s.x - mouse.x;
          const dy = s.y - mouse.y;
          // Only allow holding non-fixed stars
          if (Math.hypot(dx, dy) < 40 && !s.fixed) { // Slightly larger area for touch
            held = s;
            break;
          }
        }
      }
    });

    window.addEventListener('touchmove', e => {
      e.preventDefault(); // Varsayılan dokunma davranışını engelle
      if (e.touches.length > 0) {
        updateMouseCoordinates(e.touches[0].clientX, e.touches[0].clientY);
      }
    });

    window.addEventListener('touchend', e => {
      e.preventDefault(); // Varsayılan dokunma davranışını engelle
      // touchup event'i için mouseup ile aynı mantığı kullan
      if (!held) return;

      // Prevent interaction if words are in final static display or during animation
      if (finalDisplayActive || finalDisplayAnimationRunning) {
          held = null;
          return;
      }

      const charThrown = held.char;
      const thrownStar = held;
      // held = null; // Removed from here

      if (dynamicMode) {
        if (!secondPhase) {
          options = wordGroups[charThrown] || [];
          if (options.length > 0) {
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                if (options.length > 1) {
                    secondPhase = true;
                    currentIndex = 1;
                } else {
                    currentWord = options[0];
                    dynamicMode = false;
                    currentIndex = 1;
                }
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
          }
        } else {
          const match = options.find(w => w[1] === charThrown);
          if (match) {
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                currentWord = match;
                secondPhase = false;
                dynamicMode = false;
                currentIndex = 2;
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
          } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
          }
        }
      } else {
        let shouldAccept = false;
        let shouldIncrement = false;

        const expectedCharForCurrentIndex = currentWord[currentIndex];

        if (currentWord === 'ÇOK') {
            if (currentIndex === 0 && charThrown === 'Ç') {
                shouldAccept = true;
                shouldIncrement = true;
            } else if (currentIndex === 1 && charThrown === 'O') {
                shouldAccept = true;
                shouldIncrement = false;
            } else if (currentIndex === 1 && charThrown === 'K') {
                shouldAccept = true;
                shouldIncrement = true;
            }
        } else {
            if (charThrown === expectedCharForCurrentIndex) {
                shouldAccept = true;
                shouldIncrement = true;
            }
        }

        if (shouldAccept) {
            bumerangFırlat(thrownStar, (star) => {
                fixedLetters.push(star);
                if (shouldIncrement) {
                    currentIndex++;
                }
                recalculateFixedLetterPositions();
                checkWordCompletion();
            });
        } else {
            thrownStar.vx = mouse.mx * 0.3; thrownStar.vy = mouse.my * 0.3;
            thrownStar.fixed = false;
        }
      }
      held = null; // Ensure held is always null after touchend
    });

    window.addEventListener('keydown', e => {
      if (e.code==='Space') { reset(); return; }
      const k = e.key.toUpperCase();
      if (letters.includes(k) && !activeKeys.has(k)) {
        keyTimers[k] = Date.now(); activeKeys.add(k);
        stars.push(new Star(k));
      }
    });

    window.addEventListener('keyup', e => {
      const k = e.key.toUpperCase();
      if (activeKeys.has(k)) { delete keyTimers[k]; activeKeys.delete(k); }
    });

    window.addEventListener('keydown', e => {
      if (e.code==='Enter') {
        const shapes=['❤︎','♡'];
        for(let i=0;i<15;i++){
          const x=Math.random()*canvas.width;
          const y=Math.random()*canvas.height;
          const heart=new Star(shapes[Math.floor(Math.random()*shapes.length)]);
          heart.x=x; heart.y=y; heart.fixed=true;
          stars.push(heart);
          setTimeout(()=>{
            const idx=stars.indexOf(heart);
            if(idx!==-1) stars.splice(idx,1);
          },2000);
        }
      }
    });

    // Main animation loop
    function animate() {
      ctx.clearRect(0,0,canvas.width,canvas.height); // Clear entire canvas

      // Draw panel if words are in final display or during animation
      if (finalDisplayAnimationRunning || finalDisplayActive) {
          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Semi-transparent black
          // ctx.shadowColor = 'rgba(255, 255, 255, 0.3)'; // GLOW REMOVED
          // ctx.shadowBlur = 15; // GLOW REMOVED
          ctx.roundRect(panelRect.x, panelRect.y, panelRect.width, panelRect.height, panelRadius);
          ctx.fill();
          ctx.restore(); // Restore context (remove shadow from other drawings)
      }

      // Particles are always drawn
      particles.forEach(p=>{ p.update(); p.draw(); });
      particles = particles.filter(p=>p.life>0);

      // Stars (letters) are always drawn
      stars.forEach(s=>{ s.update(); s.draw(); }); // Star.update and Star.draw now handle isScatteredHeart and isFinalDisplayStar logic

      requestAnimationFrame(animate); // Request next animation frame
    }
    animate(); // Start animation loop
  </script>
</body>
</html>
